#!/bin/bash

set -euo pipefail

# Autogenerated by ./install.sh for the "dev" environment.

if ! command -v python3 >/dev/null 2>&1; then
  echo "python3 is required to run wctl." >&2
  exit 1
fi

resolve_realpath() {
  python3 - "$1" <<'PY'
import os
import sys
print(os.path.realpath(sys.argv[1]))
PY
}

SCRIPT_PATH="$(resolve_realpath "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(cd "$(dirname "${SCRIPT_PATH}")" && pwd)"
PROJECT_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
SOURCE_ENV="${PROJECT_DIR}/docker/.env"
COMPOSE_FILE_RELATIVE="docker/docker-compose.dev.yml"
COMPOSE_FILE="${PROJECT_DIR}/${COMPOSE_FILE_RELATIVE}"

cd "${PROJECT_DIR}" || exit 1

if [[ ! -f "${SOURCE_ENV}" ]]; then
  echo "Expected env file at ${SOURCE_ENV} (see readme quick-start)." >&2
  exit 1
fi

TEMP_ENV=$(mktemp -t wctl-env-XXXXXXXX)
cleanup() {
  rm -f "${TEMP_ENV}"
}
trap cleanup EXIT

python3 - "${SOURCE_ENV}" "${TEMP_ENV}" <<'PY'
import sys
from pathlib import Path

src = Path(sys.argv[1])
dst = Path(sys.argv[2])
lines = []
for raw in src.read_text().splitlines():
    if not raw or raw.lstrip().startswith("#"):
        lines.append(raw)
        continue
    if "=" not in raw:
        lines.append(raw)
        continue
    key, value = raw.split("=", 1)
    value = value.replace("$", "$$")
    lines.append(f"{key}={value}")
dst.write_text("\n".join(lines) + "\n")
PY

export WEPPPY_ENV_FILE="${TEMP_ENV}"

docker compose --env-file "${TEMP_ENV}" -f "${COMPOSE_FILE}" "$@"
