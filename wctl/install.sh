#!/bin/bash
# Usage (from project root):
#   ./wctl/install.sh dev   # configure wctl for docker-compose.dev.yml
#   ./wctl/install.sh prod  # configure wctl for docker-compose.prod.yml
#
# Re-run the script any time you need to switch the wctl target environment.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
WCTL_DIR="${SCRIPT_DIR}"
WCTL_SCRIPT="${WCTL_DIR}/wctl.sh"
SYMLINK_PATH="${WCTL_SYMLINK_PATH:-/usr/local/bin/wctl}"

if [[ ! -d "${WCTL_DIR}" ]]; then
  echo "Expected wctl directory at ${WCTL_DIR}" >&2
  exit 1
fi

if ! command -v python3 >/dev/null 2>&1; then
  echo "python3 is required to run this installer." >&2
  exit 1
fi

resolve_realpath() {
  python3 - "$1" <<'PY'
import os
import sys
print(os.path.realpath(sys.argv[1]))
PY
}

ENVIRONMENT="${1:-dev}"
case "${ENVIRONMENT}" in
  dev)
    COMPOSE_RELATIVE_PATH="docker/docker-compose.dev.yml"
    ;;
  prod)
    COMPOSE_RELATIVE_PATH="docker/docker-compose.prod.yml"
    ;;
  *)
    cat <<'USAGE' >&2
Usage:
  ./wctl/install.sh dev    # configure wctl for docker-compose.dev.yml
  ./wctl/install.sh prod   # configure wctl for docker-compose.prod.yml
USAGE
    exit 1
    ;;
esac

cat > "${WCTL_SCRIPT}" <<'EOF_SCRIPT'
#!/bin/bash

set -euo pipefail

# Autogenerated by ./install.sh for the "__ENVIRONMENT__" environment.

if ! command -v python3 >/dev/null 2>&1; then
  echo "python3 is required to run wctl." >&2
  exit 1
fi

resolve_realpath() {
  python3 - "$1" <<'PY'
import os
import sys
print(os.path.realpath(sys.argv[1]))
PY
}

SCRIPT_PATH="$(resolve_realpath "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(cd "$(dirname "${SCRIPT_PATH}")" && pwd)"
PROJECT_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
SOURCE_ENV="${PROJECT_DIR}/docker/.env"
COMPOSE_FILE_RELATIVE="__COMPOSE_FILE_RELATIVE__"
COMPOSE_FILE="${PROJECT_DIR}/${COMPOSE_FILE_RELATIVE}"

HOST_ENV_DEFAULT="${PROJECT_DIR}/.env"
if [[ -n "${WCTL_HOST_ENV:-}" ]]; then
  if [[ "${WCTL_HOST_ENV}" = /* ]]; then
    HOST_ENV_CANDIDATE="${WCTL_HOST_ENV}"
  else
    HOST_ENV_CANDIDATE="${PROJECT_DIR}/${WCTL_HOST_ENV}"
  fi
else
  HOST_ENV_CANDIDATE="${HOST_ENV_DEFAULT}"
fi

if [[ -n "${HOST_ENV_CANDIDATE}" && -f "${HOST_ENV_CANDIDATE}" ]]; then
  HOST_ENV="$(resolve_realpath "${HOST_ENV_CANDIDATE}")"
else
  HOST_ENV=""
fi

cd "${PROJECT_DIR}" || exit 1

if [[ ! -f "${SOURCE_ENV}" ]]; then
  echo "Expected env file at ${SOURCE_ENV} (see readme quick-start)." >&2
  exit 1
fi

TEMP_ENV=$(mktemp -t wctl-env-XXXXXXXX)
cleanup() {
  rm -f "${TEMP_ENV}"
}
trap cleanup EXIT

env_value() {
  local key="$1"
  local file="$2"
  python3 - "$key" "$file" <<'PY'
import sys
from pathlib import Path

key = sys.argv[1]
path = Path(sys.argv[2])
for raw in path.read_text().splitlines():
    if not raw or raw.lstrip().startswith("#") or "=" not in raw:
        continue
    current_key, value = raw.split("=", 1)
    if current_key == key:
        print(value)
        break
PY
}

python3 - "${SOURCE_ENV}" "${HOST_ENV}" "${TEMP_ENV}" "${COMPOSE_FILE}" <<'PY'
import sys
import os
import re
from pathlib import Path
from collections import OrderedDict

source = Path(sys.argv[1])
host_arg = sys.argv[2]
dest = Path(sys.argv[3])
compose_path = Path(sys.argv[4])

paths = [source]
if host_arg:
    host_path = Path(host_arg)
    if host_path.exists():
        paths.append(host_path)

def iter_entries(path: Path):
    for raw in path.read_text().splitlines():
        if not raw or raw.lstrip().startswith("#") or "=" not in raw:
            continue
        key, value = raw.split("=", 1)
        yield key.strip(), value

merged = OrderedDict()
for path in paths:
    for key, value in iter_entries(path):
        merged[key] = value.replace("$", "$$")

compose_keys = set()
if compose_path.exists():
    pattern = re.compile(r"\${([A-Za-z0-9_]+)")
    try:
        text = compose_path.read_text()
    except Exception:
        text = ""
    for match in pattern.finditer(text):
        compose_keys.add(match.group(1))

for key in compose_keys:
    value = os.environ.get(key)
    if value is not None:
        merged[key] = value.replace("$", "$$")

lines = [f"{key}={value}" for key, value in merged.items()]
dest.write_text("\n".join(lines) + ("\n" if lines else ""))
PY

export WEPPPY_ENV_FILE="${TEMP_ENV}"

STATIC_BUILDER="${PROJECT_DIR}/wepppy/weppcloud/static-src/build-static-assets.sh"
MANPAGE_SOURCE="${PROJECT_DIR}/wctl/wctl.1"

restore_docker_data_permissions() {
  local data_root="${PROJECT_DIR}/.docker-data"
  if [[ ! -d "${data_root}" ]]; then
    echo "No .docker-data directory at ${data_root}; nothing to do."
    return 0
  fi

  local app_uid app_gid
  app_uid="$(env_value UID "${TEMP_ENV}")"
  app_gid="$(env_value GID "${TEMP_ENV}")"
  if [[ -z "${app_uid}" ]]; then
    app_uid="33"
  fi
  if [[ -z "${app_gid}" ]]; then
    app_gid="993"
  fi

  local pg_dir="${data_root}/postgres"
  if [[ -d "${pg_dir}" ]]; then
    echo "Fixing ownership for ${pg_dir} (postgres:postgres)."
    chown -R 999:999 "${pg_dir}"
    chmod 700 "${pg_dir}"
  else
    echo "Skipping missing ${pg_dir}."
  fi

  local pg_backups_dir="${data_root}/postgres-backups"
  if [[ -d "${pg_backups_dir}" ]]; then
    echo "Fixing ownership for ${pg_backups_dir} (postgres backups)."
    chown -R 999:999 "${pg_backups_dir}"
    chmod 750 "${pg_backups_dir}"
  else
    echo "Skipping missing ${pg_backups_dir}."
  fi

  local redis_dir="${data_root}/redis"
  if [[ -d "${redis_dir}" ]]; then
    echo "Fixing ownership for ${redis_dir} (redis)."
    chown -R 999:999 "${redis_dir}"
    chmod 700 "${redis_dir}"
    local redis_aof_dir="${redis_dir}/appendonlydir"
    if [[ -d "${redis_aof_dir}" ]]; then
      chmod 700 "${redis_aof_dir}"
    fi
  else
    echo "Skipping missing ${redis_dir}."
  fi

  local weppcloud_dir="${data_root}/weppcloud"
  if [[ -d "${weppcloud_dir}" ]]; then
    echo "Fixing ownership for ${weppcloud_dir} (app runtime uid/gid)."
    chown -R "${app_uid}:${app_gid}" "${weppcloud_dir}"
    chmod 775 "${weppcloud_dir}"
    local weppcloud_logs_dir="${weppcloud_dir}/logs"
    if [[ -d "${weppcloud_logs_dir}" ]]; then
      chmod 775 "${weppcloud_logs_dir}"
    fi
  else
    echo "Skipping missing ${weppcloud_dir}."
  fi

  echo "Permission restoration completed."
}

show_wctl_manual() {
  local man_args=("$@")

  if command -v man >/dev/null 2>&1; then
    if man -w wctl >/dev/null 2>&1; then
      MANOPT= man "${man_args[@]}" wctl
      return
    fi
  fi

  if [[ -f "${MANPAGE_SOURCE}" ]]; then
    if command -v man >/dev/null 2>&1; then
      MANOPT= man "${man_args[@]}" -l "${MANPAGE_SOURCE}"
      return
    fi
    if command -v less >/dev/null 2>&1; then
      less "${MANPAGE_SOURCE}"
      return
    fi
    cat "${MANPAGE_SOURCE}"
    return
  fi

  echo "wctl manual page not found (expected ${MANPAGE_SOURCE})." >&2
  return 1
}

compose_exec_weppcloud() {
  local exec_cmd="$1"
  docker compose --env-file "${TEMP_ENV}" -f "${COMPOSE_FILE}" exec weppcloud bash -lc "${exec_cmd}"
}

quote_args() {
  local first=1
  for arg in "$@"; do
    if [[ ${first} -eq 1 ]]; then
      printf '%q' "$arg"
      first=0
    else
      printf ' %q' "$arg"
    fi
  done
}

if [[ $# -gt 0 ]]; then
  case "$1" in
    build-static-assets)
      shift
      if [[ ! -x "${STATIC_BUILDER}" ]]; then
        echo "Static asset build script not found at ${STATIC_BUILDER}" >&2
        exit 1
      fi
      STATIC_ARGS=()
      if [[ "${COMPOSE_FILE_RELATIVE}" == "docker/docker-compose.prod.yml" ]]; then
        STATIC_ARGS+=(--prod)
      fi
      "${STATIC_BUILDER}" "${STATIC_ARGS[@]}" "$@"
      exit 0
      ;;
    restore-docker-data-permissions)
      shift
      restore_docker_data_permissions
      exit 0
      ;;
    man)
      shift
      show_wctl_manual "$@"
      exit 0
      ;;
    update-stub-requirements)
      shift
      python3 "${PROJECT_DIR}/tools/update_stub_requirements.py" "$@"
      exit 0
      ;;
    run-pytest)
      shift
      if [[ $# -eq 0 ]]; then
        set -- tests
      fi
      CMD_ARGS=$(quote_args "$@")
      compose_exec_weppcloud "cd /workdir/wepppy && PYTHONPATH=/workdir/wepppy MYPY_CACHE_DIR=/tmp/mypy_cache /opt/venv/bin/pytest ${CMD_ARGS}"
      exit 0
      ;;
    run-stubtest)
      shift
      if [[ $# -eq 0 ]]; then
        set -- wepppy.nodb.core
      fi
      CMD_ARGS=$(quote_args "$@")
      compose_exec_weppcloud "cd /tmp && PYTHONPATH=/workdir/wepppy MYPY_CACHE_DIR=/tmp/mypy_cache /opt/venv/bin/stubtest ${CMD_ARGS}"
      exit 0
      ;;
    run-npm)
      shift
      if ! command -v npm >/dev/null 2>&1; then
        echo "npm is required for run-npm." >&2
        exit 1
      fi
      NPM_PREFIX="${PROJECT_DIR}/wepppy/weppcloud/static-src"
      if [[ $# -eq 0 ]]; then
        npm --prefix "${NPM_PREFIX}"
      else
        case "$1" in
          install|ci|update|exec|run|init|publish|link|login|logout|cache|config|set|get|rebuild|outdated|dedupe|audit|doctor|fund)
            npm --prefix "${NPM_PREFIX}" "$@"
            ;;
          *)
            npm --prefix "${NPM_PREFIX}" run "$@"
            ;;
        esac
      fi
      exit 0
      ;;
    run-stubgen)
      shift
      python3 "${PROJECT_DIR}/tools/sync_stubs.py" "$@"
      exit 0
      ;;
    check-test-stubs)
      shift
      compose_exec_weppcloud "cd /workdir/wepppy && python tools/check_stubs.py"
      exit 0
      ;;
    check-test-isolation)
      shift
      CMD_ARGS=$(quote_args "$@")
      compose_exec_weppcloud "cd /workdir/wepppy && python tools/check_test_isolation.py ${CMD_ARGS}"
      exit 0
      ;;
  esac
fi

docker compose --env-file "${TEMP_ENV}" -f "${COMPOSE_FILE}" "$@"
EOF_SCRIPT

python3 - "${WCTL_SCRIPT}" "${ENVIRONMENT}" "${COMPOSE_RELATIVE_PATH}" <<'PY'
import sys
from pathlib import Path

path = Path(sys.argv[1])
environment = sys.argv[2]
compose_relative = sys.argv[3]
text = path.read_text()
text = text.replace("__ENVIRONMENT__", environment)
text = text.replace("__COMPOSE_FILE_RELATIVE__", compose_relative)
path.write_text(text)
PY

chmod +x "${WCTL_SCRIPT}"

echo "wctl configured for ${ENVIRONMENT} environment (${COMPOSE_RELATIVE_PATH})."

TARGET_REALPATH="$(resolve_realpath "${WCTL_SCRIPT}")"
SYMLINK_UPDATED=false

if [[ -n "${SYMLINK_PATH}" ]]; then
  if [[ -L "${SYMLINK_PATH}" ]]; then
    EXISTING_REALPATH="$(resolve_realpath "${SYMLINK_PATH}")"
    if [[ "${EXISTING_REALPATH}" == "${TARGET_REALPATH}" ]]; then
      echo "Symlink already up to date at ${SYMLINK_PATH}."
      SYMLINK_UPDATED=true
    fi
  fi

  if [[ "${SYMLINK_UPDATED}" == false ]]; then
    if [[ -e "${SYMLINK_PATH}" && ! -L "${SYMLINK_PATH}" ]]; then
      echo "Cannot create symlink at ${SYMLINK_PATH}: path exists and is not a symlink. Remove it or set WCTL_SYMLINK_PATH to a custom location." >&2
    else
      if ln -sfn "${WCTL_SCRIPT}" "${SYMLINK_PATH}"; then
        echo "Symlink created at ${SYMLINK_PATH} -> ${WCTL_SCRIPT}."
      else
        echo "Failed to create symlink at ${SYMLINK_PATH}. Try running with elevated permissions or set WCTL_SYMLINK_PATH to a writable location." >&2
      fi
    fi
  fi
fi

MANPAGE_DEST="${WCTL_MAN_PATH:-/usr/local/share/man/man1/wctl.1}"
MANPAGE_SOURCE_FILE="${WCTL_DIR}/wctl.1"

if [[ -n "${MANPAGE_DEST}" ]]; then
  if [[ ! -f "${MANPAGE_SOURCE_FILE}" ]]; then
    echo "Skipping man page install: source ${MANPAGE_SOURCE_FILE} not found." >&2
  else
    MANPAGE_DIR="$(dirname "${MANPAGE_DEST}")"
    if [[ ! -d "${MANPAGE_DIR}" ]]; then
      if mkdir -p "${MANPAGE_DIR}" 2>/dev/null; then
        :
      else
        echo "Could not create ${MANPAGE_DIR}; run the installer with elevated permissions or set WCTL_MAN_PATH to a writable directory to install the man page." >&2
        MANPAGE_DIR=""
      fi
    fi
    if [[ -n "${MANPAGE_DIR}" && -d "${MANPAGE_DIR}" ]]; then
      if cp "${MANPAGE_SOURCE_FILE}" "${MANPAGE_DEST}" 2>/dev/null; then
        echo "Man page installed at ${MANPAGE_DEST}."
      else
        echo "Failed to install man page at ${MANPAGE_DEST}; try running with elevated permissions or set WCTL_MAN_PATH." >&2
      fi
    fi
  fi
fi
