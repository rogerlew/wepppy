#!/bin/bash
# Usage (from project root):
#   ./wctl/install.sh dev   # configure wctl for docker-compose.dev.yml
#   ./wctl/install.sh prod  # configure wctl for docker-compose.prod.yml
#
# Re-run the script any time you need to switch the wctl target environment.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
WCTL_DIR="${SCRIPT_DIR}"
WCTL_SCRIPT="${WCTL_DIR}/wctl.sh"
SYMLINK_PATH="${WCTL_SYMLINK_PATH:-/usr/local/bin/wctl}"

if [[ ! -d "${WCTL_DIR}" ]]; then
  echo "Expected wctl directory at ${WCTL_DIR}" >&2
  exit 1
fi

if ! command -v python3 >/dev/null 2>&1; then
  echo "python3 is required to run this installer." >&2
  exit 1
fi

resolve_realpath() {
  python3 - "$1" <<'PY'
import os
import sys
print(os.path.realpath(sys.argv[1]))
PY
}

ENVIRONMENT="${1:-dev}"
case "${ENVIRONMENT}" in
  dev)
    COMPOSE_RELATIVE_PATH="docker/docker-compose.dev.yml"
    ;;
  prod)
    COMPOSE_RELATIVE_PATH="docker/docker-compose.prod.yml"
    ;;
  *)
    cat <<'USAGE' >&2
Usage:
  ./wctl/install.sh dev    # configure wctl for docker-compose.dev.yml
  ./wctl/install.sh prod   # configure wctl for docker-compose.prod.yml
USAGE
    exit 1
    ;;
esac

cat > "${WCTL_SCRIPT}" <<'EOF_SCRIPT'
#!/bin/bash

set -euo pipefail

# Autogenerated by ./install.sh for the "__ENVIRONMENT__" environment.

if ! command -v python3 >/dev/null 2>&1; then
  echo "python3 is required to run wctl." >&2
  exit 1
fi

resolve_realpath() {
  python3 - "$1" <<'PY'
import os
import sys
print(os.path.realpath(sys.argv[1]))
PY
}

SCRIPT_PATH="$(resolve_realpath "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(cd "$(dirname "${SCRIPT_PATH}")" && pwd)"
PROJECT_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
SOURCE_ENV="${PROJECT_DIR}/docker/.env"
COMPOSE_FILE_RELATIVE="__COMPOSE_FILE_RELATIVE__"
COMPOSE_FILE="${PROJECT_DIR}/${COMPOSE_FILE_RELATIVE}"

cd "${PROJECT_DIR}" || exit 1

if [[ ! -f "${SOURCE_ENV}" ]]; then
  echo "Expected env file at ${SOURCE_ENV} (see readme quick-start)." >&2
  exit 1
fi

TEMP_ENV=$(mktemp -t wctl-env-XXXXXXXX)
cleanup() {
  rm -f "${TEMP_ENV}"
}
trap cleanup EXIT

env_value() {
  local key="$1"
  local file="$2"
  python3 - "$key" "$file" <<'PY'
import sys
from pathlib import Path

key = sys.argv[1]
path = Path(sys.argv[2])
for raw in path.read_text().splitlines():
    if not raw or raw.lstrip().startswith("#") or "=" not in raw:
        continue
    current_key, value = raw.split("=", 1)
    if current_key == key:
        print(value)
        break
PY
}

python3 - "${SOURCE_ENV}" "${TEMP_ENV}" <<'PY'
import sys
from pathlib import Path

src = Path(sys.argv[1])
dst = Path(sys.argv[2])
lines = []
for raw in src.read_text().splitlines():
    if not raw or raw.lstrip().startswith("#"):
        lines.append(raw)
        continue
    if "=" not in raw:
        lines.append(raw)
        continue
    key, value = raw.split("=", 1)
    value = value.replace("$", "$$")
    lines.append(f"{key}={value}")
dst.write_text("\n".join(lines) + "\n")
PY

export WEPPPY_ENV_FILE="${TEMP_ENV}"

STATIC_BUILDER="${PROJECT_DIR}/wepppy/weppcloud/static-src/build-static-assets.sh"
MANPAGE_SOURCE="${PROJECT_DIR}/wctl/wctl.1"

restore_docker_data_permissions() {
  local data_root="${PROJECT_DIR}/.docker-data"
  if [[ ! -d "${data_root}" ]]; then
    echo "No .docker-data directory at ${data_root}; nothing to do."
    return 0
  fi

  local app_uid app_gid
  app_uid="$(env_value UID "${TEMP_ENV}")"
  app_gid="$(env_value GID "${TEMP_ENV}")"
  if [[ -z "${app_uid}" ]]; then
    app_uid="33"
  fi
  if [[ -z "${app_gid}" ]]; then
    app_gid="993"
  fi

  local pg_dir="${data_root}/postgres"
  if [[ -d "${pg_dir}" ]]; then
    echo "Fixing ownership for ${pg_dir} (postgres:postgres)."
    chown -R 999:999 "${pg_dir}"
    chmod 700 "${pg_dir}"
  else
    echo "Skipping missing ${pg_dir}."
  fi

  local pg_backups_dir="${data_root}/postgres-backups"
  if [[ -d "${pg_backups_dir}" ]]; then
    echo "Fixing ownership for ${pg_backups_dir} (postgres backups)."
    chown -R 999:999 "${pg_backups_dir}"
    chmod 750 "${pg_backups_dir}"
  else
    echo "Skipping missing ${pg_backups_dir}."
  fi

  local redis_dir="${data_root}/redis"
  if [[ -d "${redis_dir}" ]]; then
    echo "Fixing ownership for ${redis_dir} (redis)."
    chown -R 999:999 "${redis_dir}"
    chmod 700 "${redis_dir}"
    local redis_aof_dir="${redis_dir}/appendonlydir"
    if [[ -d "${redis_aof_dir}" ]]; then
      chmod 700 "${redis_aof_dir}"
    fi
  else
    echo "Skipping missing ${redis_dir}."
  fi

  local weppcloud_dir="${data_root}/weppcloud"
  if [[ -d "${weppcloud_dir}" ]]; then
    echo "Fixing ownership for ${weppcloud_dir} (app runtime uid/gid)."
    chown -R "${app_uid}:${app_gid}" "${weppcloud_dir}"
    chmod 775 "${weppcloud_dir}"
    local weppcloud_logs_dir="${weppcloud_dir}/logs"
    if [[ -d "${weppcloud_logs_dir}" ]]; then
      chmod 775 "${weppcloud_logs_dir}"
    fi
  else
    echo "Skipping missing ${weppcloud_dir}."
  fi

  echo "Permission restoration completed."
}

show_wctl_manual() {
  local man_args=("$@")

  if command -v man >/dev/null 2>&1; then
    if man -w wctl >/dev/null 2>&1; then
      MANOPT= man "${man_args[@]}" wctl
      return
    fi
  fi

  if [[ -f "${MANPAGE_SOURCE}" ]]; then
    if command -v man >/dev/null 2>&1; then
      MANOPT= man "${man_args[@]}" -l "${MANPAGE_SOURCE}"
      return
    fi
    if command -v less >/dev/null 2>&1; then
      less "${MANPAGE_SOURCE}"
      return
    fi
    cat "${MANPAGE_SOURCE}"
    return
  fi

  echo "wctl manual page not found (expected ${MANPAGE_SOURCE})." >&2
  return 1
}

if [[ $# -gt 0 ]]; then
  case "$1" in
    build-static-assets)
      shift
      if [[ ! -x "${STATIC_BUILDER}" ]]; then
        echo "Static asset build script not found at ${STATIC_BUILDER}" >&2
        exit 1
      fi
      STATIC_ARGS=()
      if [[ "${COMPOSE_FILE_RELATIVE}" == "docker/docker-compose.prod.yml" ]]; then
        STATIC_ARGS+=(--prod)
      fi
      "${STATIC_BUILDER}" "${STATIC_ARGS[@]}" "$@"
      exit 0
      ;;
    restore-docker-data-permissions)
      shift
      restore_docker_data_permissions
      exit 0
      ;;
    man)
      shift
      show_wctl_manual "$@"
      exit 0
      ;;
    update-stub-requirements)
      shift
      python3 "${PROJECT_DIR}/tools/update_stub_requirements.py" "$@"
      exit 0
      ;;
  esac
fi

docker compose --env-file "${TEMP_ENV}" -f "${COMPOSE_FILE}" "$@"
EOF_SCRIPT

python3 - "${WCTL_SCRIPT}" "${ENVIRONMENT}" "${COMPOSE_RELATIVE_PATH}" <<'PY'
import sys
from pathlib import Path

path = Path(sys.argv[1])
environment = sys.argv[2]
compose_relative = sys.argv[3]
text = path.read_text()
text = text.replace("__ENVIRONMENT__", environment)
text = text.replace("__COMPOSE_FILE_RELATIVE__", compose_relative)
path.write_text(text)
PY

chmod +x "${WCTL_SCRIPT}"

echo "wctl configured for ${ENVIRONMENT} environment (${COMPOSE_RELATIVE_PATH})."

TARGET_REALPATH="$(resolve_realpath "${WCTL_SCRIPT}")"
SYMLINK_UPDATED=false

if [[ -n "${SYMLINK_PATH}" ]]; then
  if [[ -L "${SYMLINK_PATH}" ]]; then
    EXISTING_REALPATH="$(resolve_realpath "${SYMLINK_PATH}")"
    if [[ "${EXISTING_REALPATH}" == "${TARGET_REALPATH}" ]]; then
      echo "Symlink already up to date at ${SYMLINK_PATH}."
      SYMLINK_UPDATED=true
    fi
  fi

  if [[ "${SYMLINK_UPDATED}" == false ]]; then
    if [[ -e "${SYMLINK_PATH}" && ! -L "${SYMLINK_PATH}" ]]; then
      echo "Cannot create symlink at ${SYMLINK_PATH}: path exists and is not a symlink. Remove it or set WCTL_SYMLINK_PATH to a custom location." >&2
    else
      if ln -sfn "${WCTL_SCRIPT}" "${SYMLINK_PATH}"; then
        echo "Symlink created at ${SYMLINK_PATH} -> ${WCTL_SCRIPT}."
      else
        echo "Failed to create symlink at ${SYMLINK_PATH}. Try running with elevated permissions or set WCTL_SYMLINK_PATH to a writable location." >&2
      fi
    fi
  fi
fi

MANPAGE_DEST="${WCTL_MAN_PATH:-/usr/local/share/man/man1/wctl.1}"
MANPAGE_SOURCE_FILE="${WCTL_DIR}/wctl.1"

if [[ -n "${MANPAGE_DEST}" ]]; then
  if [[ ! -f "${MANPAGE_SOURCE_FILE}" ]]; then
    echo "Skipping man page install: source ${MANPAGE_SOURCE_FILE} not found." >&2
  else
    MANPAGE_DIR="$(dirname "${MANPAGE_DEST}")"
    if [[ ! -d "${MANPAGE_DIR}" ]]; then
      if mkdir -p "${MANPAGE_DIR}" 2>/dev/null; then
        :
      else
        echo "Could not create ${MANPAGE_DIR}; run the installer with elevated permissions or set WCTL_MAN_PATH to a writable directory to install the man page." >&2
        MANPAGE_DIR=""
      fi
    fi
    if [[ -n "${MANPAGE_DIR}" && -d "${MANPAGE_DIR}" ]]; then
      if cp "${MANPAGE_SOURCE_FILE}" "${MANPAGE_DEST}" 2>/dev/null; then
        echo "Man page installed at ${MANPAGE_DEST}."
      else
        echo "Failed to install man page at ${MANPAGE_DEST}; try running with elevated permissions or set WCTL_MAN_PATH." >&2
      fi
    fi
  fi
fi
