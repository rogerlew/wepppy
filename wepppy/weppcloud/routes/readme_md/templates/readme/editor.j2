<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>{{ runid }}/README Editor{% if ron.name %} - {{ ron.name }}{% endif %}</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="https://code.jquery.com/jquery-3.5.1.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>
    <script src="{{ url_for('static', filename='js/controllers.js') }}"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.8.1/github-markdown-light.css" integrity="sha512-CxC9MO8FBaaq8vl9yaXHjgWd7uXqx3pWMSBP3daioTTI0gpXijlypuMV67NoE1bPYMzj7ZSNNS0o+jFFdFodgA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        width: 100%;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      @media (max-width: 767.98px) {
        .markdown-body {
          padding: 15px;
        }
      }

      .readme-editor-container {
        display: flex;
        flex-direction: row;
        gap: 1rem;
        padding: 1rem;
      }

      .readme-editor-container > div {
        flex: 1 1 50%;
        min-height: 75vh;
        display: flex;
        flex-direction: column;
      }

      #readme-editor {
        width: 100%;
        flex: 1 1 auto;
        min-height: 75vh;
        font-family: monospace;
      }

      #readme-preview {
        flex: 1 1 auto;
        overflow-y: auto;
        border: 1px solid #ccc;
        background-color: #ffffff;
      }

      .readme-lock-overlay {
        position: fixed;
        inset: 0;
        background-color: rgba(0, 0, 0, 0.65);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1.5rem;
        z-index: 2050;
      }

      .readme-lock-overlay[hidden] {
        display: none;
      }

      .readme-lock-dialog {
        max-width: 420px;
        width: 100%;
        background: #ffffff;
        border-radius: 0.5rem;
        padding: 2rem 1.5rem;
        text-align: center;
        box-shadow: 0 0.75rem 1.5rem rgba(0, 0, 0, 0.35);
      }

      .readme-lock-dialog h4 {
        margin-bottom: 0.75rem;
      }

      .readme-lock-dialog p {
        margin-bottom: 1.25rem;
      }
    </style>
  </head>
  <body>
    {% include 'command_bar/command-bar.htm' %}
    <div class="container-fluid mt-4">
      <div class="d-flex flex-column flex-lg-row justify-content-between align-items-lg-center gap-3 mb-3">
        <div>
          <h2 class="mb-1"><a href="{{ url_for_run('run_0.runs0', runid=runid, config=config) }}">{{ runid }}</a> README.md Editor</h2>
          <p class="text-muted mb-2">Changes are saved automatically (and with Ctrl+S).</p>
        </div>
        <div class="btn-group btn-group-toggle btn-group-lg" data-toggle="buttons" role="group" aria-label="README mode">
          <label class="btn btn-secondary btn-lg">
            <input type="radio" name="readme-mode" autocomplete="off" onclick="window.location.href='{{ url_for_run('readme.readme_render', runid=runid, config=config) }}'"> View
          </label>
          <label class="btn btn-secondary btn-lg active">
            <input type="radio" name="readme-mode" autocomplete="off" checked> Edit
          </label>
        </div>
      </div>
      <div>
        <p class="text-muted mb-2">
          <b>Caution:</b><br>
          README.md files are stored unencrypted; avoid adding passwords, secrets, or other sensitive information.
        </p>
      </div>
      <div class="readme-editor-container">
        <div>
          <textarea id="readme-editor" class="form-control" spellcheck="false">{{ initial_markdown }}</textarea>
        </div>
        <div>
          <article id="readme-preview" class="markdown-body">{{ initial_html | safe }}</article>
        </div>
      </div>
    </div>
    <div id="readme-lock-overlay" class="readme-lock-overlay" hidden role="alertdialog" aria-modal="true" aria-labelledby="readme-lock-title">
      <div class="readme-lock-dialog">
        <h4 id="readme-lock-title">Editor Locked</h4>
        <p>Another README editor tab has taken over this project. This editor is now read-only.</p>
        <button id="readme-lock-reload" type="button" class="btn btn-primary">Reload Editor</button>
      </div>
    </div>
    <script>
      (function() {
        const runid = {{ runid | tojson }};
        const config = {{ config | tojson }};
        const clientUuid = {{ editor_client_uuid | tojson }};
        const initialRonName = {{ (ron.name or '') | tojson }};
        const initialRonScenario = {{ (ron.scenario or '') | tojson }};
        const editor = document.getElementById('readme-editor');
        const previewEl = document.getElementById('readme-preview');
        const saveUrl = {{ url_for_run('readme.readme_save', runid=runid, config=config) | tojson }};
        const previewUrl = {{ url_for_run('readme.readme_preview', runid=runid, config=config) | tojson }};
        const rawUrl = {{ url_for_run('readme.readme_raw', runid=runid, config=config) | tojson }};
        const lockOverlay = document.getElementById('readme-lock-overlay');
        const reloadButton = document.getElementById('readme-lock-reload');
        let saveTimer = null;
        let previewTimer = null;
        const SAVE_DEBOUNCE = 2000;
        const PREVIEW_DEBOUNCE = 600;
        const baseDocumentTitle = `${runid}/README Editor`;
        let currentRonName = initialRonName;
        let currentRonScenario = initialRonScenario;
        let invalidated = false;

        const commandProject = window.Project ? window.Project.getInstance() : null;

        function updateDocumentTitle() {
          const suffix = currentRonName ? ` - ${currentRonName}` : '';
          document.title = `${baseDocumentTitle}${suffix}`;
        }

        updateDocumentTitle();

        function notify(message) {
          if (commandProject && typeof commandProject._notifyCommandBar === 'function') {
            commandProject._notifyCommandBar(message);
          }
        }

        function invalidateEditor() {
          if (invalidated) {
            return;
          }
          invalidated = true;
          clearTimeout(saveTimer);
          clearTimeout(previewTimer);
          editor.setAttribute('disabled', 'disabled');
          if (lockOverlay) {
            lockOverlay.hidden = false;
          }
          notify('This README editor tab is no longer active.');
        }

        if (reloadButton) {
          reloadButton.addEventListener('click', () => {
            window.location.reload();
          });
        }

        function requestPreview() {
          if (invalidated) {
            return;
          }
          fetch(previewUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ markdown: editor.value, uuid: clientUuid })
          })
            .then(resp => resp.json())
            .then(body => {
              if (body && typeof body.html === 'string') {
                previewEl.innerHTML = body.html;
              }
            })
            .catch(err => console.error('Preview failed:', err));
        }

        function refreshPreviewNow() {
          requestPreview();
        }

        function performSave() {
          if (invalidated) {
            return;
          }
          saveTimer = null;
          fetch(saveUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ markdown: editor.value, uuid: clientUuid })
          })
            .then(resp => resp.json())
            .then(body => {
              if (!body) {
                notify('Error saving README.md');
                return;
              }
              if (body.invalidated) {
                invalidateEditor();
                return;
              }
              if (body.Success) {
                if (body.ronUpdate) {
                  handleRonUpdate(body.ronUpdate);
                }
                notify('Saved README.md');
              } else {
                notify('Error saving README.md');
              }
            })
            .catch(err => {
              console.error('Save failed:', err);
              notify('Error saving README.md');
            });
        }

        function fetchLatest() {
          if (invalidated) {
            return;
          }
          fetch(rawUrl)
            .then(resp => resp.json())
            .then(body => {
              if (body && typeof body.markdown === 'string') {
                editor.value = body.markdown;
                queuePreview();
              }
            })
            .catch(err => console.error('Unable to load README:', err));
        }

        function queueSave() {
          if (invalidated) {
            return;
          }
          clearTimeout(saveTimer);
          saveTimer = setTimeout(performSave, SAVE_DEBOUNCE);
        }

        function queuePreview() {
          if (invalidated) {
            return;
          }
          clearTimeout(previewTimer);
          previewTimer = setTimeout(requestPreview, PREVIEW_DEBOUNCE);
        }

        editor.addEventListener('input', () => {
          queuePreview();
          queueSave();
        });

        window.addEventListener('keydown', event => {
          if (invalidated) {
            return;
          }
          if ((event.ctrlKey || event.metaKey) && (event.key === 's' || event.key === 'S')) {
            event.preventDefault();
            clearTimeout(saveTimer);
            performSave();
          }
        });

        // Ensure initial preview matches template rendering
        queuePreview();

        // Optionally refresh from server if another user modified it
        // fetchLatest();

        function handleRonUpdate(update) {
          const updates = update || {};
          if (Object.prototype.hasOwnProperty.call(updates, 'name')) {
            currentRonName = updates.name || '';
          }
          if (Object.prototype.hasOwnProperty.call(updates, 'scenario')) {
            currentRonScenario = updates.scenario || '';
          }
          updateDocumentTitle();
          refreshPreviewNow();
        }
      })();
    </script>
  </body>
</html>
