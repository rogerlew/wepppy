{% extends "base_pure.htm" %}

{% block title %}{{ runid }}/README Editor{% if ron.name %} - {{ ron.name }}{% endif %}{% endblock %}

{% block head_extras %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/markdown-theme.css') }}">
<script src="{{ url_for('static', filename='js/controllers.js') }}" defer></script>
{% endblock %}

{% from "shared/console_macros.htm" import console_page, console_header %}

{% block body %}
{% call console_page(include_command_bar=True) %}
  {% set header_actions = [
    {
      "href": url_for_run('readme.readme_render', runid=runid, config=config),
      "label": "View",
      "variant": "pure-button-secondary"
    },
    {
      "element": "button",
      "label": "Edit",
      "type": "button",
      "disabled": True
    }
  ] %}
  {% call console_header(
    run_link=url_for_run('run_0.runs0', runid=runid, config=config),
    run_label=runid,
    run_target='_self',
    run_rel=None,
    title="README.md Editor",
    subtitle="Changes are saved automatically and on Ctrl+S.",
    actions=header_actions
  ) %}{% endcall %}

  <div class="wc-note">
    <strong>Caution:</strong> README.md files are stored unencrypted; avoid adding passwords, secrets, or other sensitive information.
  </div>

  <div class="wc-editor-grid">
    <div class="wc-editor-pane">
      <textarea id="readme-editor" class="wc-editor-textarea" spellcheck="false">{{ initial_markdown }}</textarea>
    </div>
    <div class="wc-editor-pane">
      <article id="readme-preview" class="markdown-body wc-editor-preview">{{ initial_html | safe }}</article>
    </div>
  </div>
{% endcall %}

<div id="readme-lock-overlay" class="wc-overlay" hidden role="alertdialog" aria-modal="true" aria-labelledby="readme-lock-title">
  <div class="wc-overlay__dialog">
    <h4 id="readme-lock-title">Editor Locked</h4>
    <p>Another README editor tab has taken over this project. This editor is now read-only.</p>
    <button id="readme-lock-reload" type="button" class="pure-button">Reload Editor</button>
  </div>
</div>

<script>
(function() {
  const runid = {{ runid | tojson }};
  const config = {{ config | tojson }};
  const clientUuid = {{ editor_client_uuid | tojson }};
  const initialRonName = {{ (ron.name or '') | tojson }};
  const initialRonScenario = {{ (ron.scenario or '') | tojson }};
  const editor = document.getElementById('readme-editor');
  const previewEl = document.getElementById('readme-preview');
  const saveUrl = {{ url_for_run('readme.readme_save', runid=runid, config=config) | tojson }};
  const previewUrl = {{ url_for_run('readme.readme_preview', runid=runid, config=config) | tojson }};
  const rawUrl = {{ url_for_run('readme.readme_raw', runid=runid, config=config) | tojson }};
  const lockOverlay = document.getElementById('readme-lock-overlay');
  const reloadButton = document.getElementById('readme-lock-reload');
  let saveTimer = null;
  let previewTimer = null;
  const SAVE_DEBOUNCE = 2000;
  const PREVIEW_DEBOUNCE = 600;
  const baseDocumentTitle = `${runid}/README Editor`;
  let currentRonName = initialRonName;
  let currentRonScenario = initialRonScenario;
  let invalidated = false;

  const commandProject = window.Project ? window.Project.getInstance() : null;

  function updateDocumentTitle() {
    const suffix = currentRonName ? ` - ${currentRonName}` : '';
    document.title = `${baseDocumentTitle}${suffix}`;
  }

  updateDocumentTitle();

  function notify(message) {
    if (commandProject && typeof commandProject._notifyCommandBar === 'function') {
      commandProject._notifyCommandBar(message);
    }
  }

  function invalidateEditor() {
    if (invalidated) {
      return;
    }
    invalidated = true;
    clearTimeout(saveTimer);
    clearTimeout(previewTimer);
    editor.setAttribute('disabled', 'disabled');
    if (lockOverlay) {
      lockOverlay.hidden = false;
    }
    notify('This README editor tab is no longer active.');
  }

  if (reloadButton) {
    reloadButton.addEventListener('click', () => {
      window.location.reload();
    });
  }

  function requestPreview() {
    if (invalidated) {
      return;
    }
    fetch(previewUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ markdown: editor.value, uuid: clientUuid })
    })
      .then(resp => resp.json())
      .then(body => {
        if (body && typeof body.html === 'string') {
          previewEl.innerHTML = body.html;
        }
      })
      .catch((err) => {
        console.error('Preview failed', err);
      });
  }

  function schedulePreview() {
    clearTimeout(previewTimer);
    previewTimer = setTimeout(requestPreview, PREVIEW_DEBOUNCE);
  }

  function saveMarkdown() {
    if (invalidated) {
      return;
    }
    fetch(saveUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ markdown: editor.value, uuid: clientUuid })
    })
      .then(resp => resp.json())
      .then(body => {
        if (body && body.status === 'locked') {
          invalidateEditor();
          return;
        }
        if (body && body.ron_name !== undefined) {
          currentRonName = body.ron_name;
          currentRonScenario = body.ron_scenario;
          updateDocumentTitle();
        }
        notify('README saved.');
      })
      .catch((err) => {
        console.error('Save failed', err);
        notify('Failed to save README.');
      });
  }

  function scheduleSave() {
    clearTimeout(saveTimer);
    saveTimer = setTimeout(saveMarkdown, SAVE_DEBOUNCE);
  }

  function handleInput() {
    if (invalidated) {
      return;
    }
    scheduleSave();
    schedulePreview();
  }

  function handleKeydown(event) {
    if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 's') {
      event.preventDefault();
      clearTimeout(saveTimer);
      saveMarkdown();
    }
  }

  function handleVisibilityChange() {
    if (document.visibilityState === 'hidden') {
      clearTimeout(saveTimer);
      clearTimeout(previewTimer);
      saveMarkdown();
    }
  }

  function pollLock() {
    fetch(rawUrl, { headers: { 'X-Readme-Client': clientUuid } })
      .then(resp => resp.json())
      .then(body => {
        if (body && body.locked_out) {
          invalidateEditor();
        }
      })
      .catch(() => {});
  }

  editor.addEventListener('input', handleInput);
  document.addEventListener('keydown', handleKeydown);
  document.addEventListener('visibilitychange', handleVisibilityChange);
  window.addEventListener('beforeunload', () => {
    clearTimeout(saveTimer);
    clearTimeout(previewTimer);
  });

  setInterval(pollLock, 5000);
})();
</script>
{% endblock %}
