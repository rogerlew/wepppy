{% extends "base_pure.htm" %}

{% block title %}Archive Dashboard â€“ {{ runid }}{% endblock %}

{% from "shared/console_macros.htm" import console_page, console_header, button_row %}

{% block body %}
{% call console_page(data_controller="archive-dashboard") %}
  {% call console_header(
    run_link=url_for_run('run_0.runs0', runid=runid, config=config),
    run_label=runid,
    title="Archive Dashboard"
  ) %}
    <p id="project_label" class="wc-text-muted">Create and manage project archives.</p>
  {% endcall %}

  <section class="wc-panel wc-stack">
    <h2>Create Archive</h2>
    <form class="pure-form pure-form-aligned" id="archive_form" novalidate>
      <fieldset>
        <div class="pure-control-group">
          <label for="archive_comment">Archive comment</label>
          <input id="archive_comment" type="text" class="pure-input-1" maxlength="40"
                 placeholder="Optional note stored with the archive">
        </div>
        {% call button_row(form_controls=True) %}
          <button type="button" class="pure-button" id="archive_button">Create archive</button>
          <button type="button" class="pure-button pure-button-secondary" id="refresh_button">Refresh list</button>
        {% endcall %}
      </fieldset>
    </form>
  </section>

  <section class="wc-panel wc-stack">
    <h2>Status</h2>
    <div id="status_log" class="wc-log" aria-live="polite"></div>
  </section>

  <section class="wc-panel wc-stack">
    <h2>Existing Archives</h2>
    <p id="archive_empty" class="wc-text-muted" hidden>No archives available.</p>
    <div class="wc-table-wrapper">
      <table class="wc-table" id="archives_table" aria-describedby="archive_empty">
        <thead>
          <tr>
            <th scope="col">Name</th>
            <th scope="col">Comment</th>
            <th scope="col">Size</th>
            <th scope="col">Created</th>
            <th scope="col">Download</th>
            <th scope="col">Restore</th>
            <th scope="col">Delete</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div id="restore_link" class="wc-inline"></div>
  </section>
{% endcall %}
{% endblock %}

{% block script_extras %}
<script>
(function () {
  const runid = {{ runid | tojson }};
  const config = {{ config | tojson }};
  const archivesUrl = {{ url_for_run('archive.rq_archive_list', runid=runid, config=config) | tojson }};
  const archiveApiUrl = {{ url_for_run('rq_api.api_archive', runid=runid, config=config) | tojson }};
  const restoreApiUrl = {{ url_for_run('rq_api.api_restore_archive', runid=runid, config=config) | tojson }};
  const deleteApiUrl = {{ url_for_run('rq_api.api_delete_archive', runid=runid, config=config) | tojson }};
  const projectPath = {{ url_for_run('run_0.runs0', runid=runid, config=config) | tojson }};
  const isUserAnonymous = {{ user.is_anonymous | tojson }};
  const MAX_STATUS_MESSAGES = 3000;

  let currentJobId = null;
  let statusLogMessages = [];

  const statusLog = document.getElementById('status_log');
  const archiveEmpty = document.getElementById('archive_empty');
  const archiveButton = document.getElementById('archive_button');
  const refreshButton = document.getElementById('refresh_button');
  const commentInput = document.getElementById('archive_comment');
  const restoreLink = document.getElementById('restore_link');
  const tableBody = document.querySelector('#archives_table tbody');

  class WSClient {
    constructor(runid, channel) {
      this.channel = channel;
      this.wsUrl = `wss://${window.location.host}/weppcloud-microservices/status/${runid}:${channel}`;
      this.ws = null;
      this.shouldReconnect = true;
    }

    connect() {
      if (this.ws) {
        return;
      }
      this.shouldReconnect = true;
      this.ws = new WebSocket(this.wsUrl);
      this.ws.onopen = () => {
        if (this.ws.readyState === WebSocket.OPEN) {
          this.ws.send(JSON.stringify({ type: 'init' }));
        }
      };
      this.ws.onmessage = (event) => {
        try {
          const payload = JSON.parse(event.data);
          if (payload.type === 'ping') {
            this.ws.send(JSON.stringify({ type: 'pong' }));
            return;
          }
          if (payload.type === 'status') {
            const data = payload.data;
            appendStatus(data);
            if (typeof data === 'string' && data.includes('TRIGGER')) {
              const parts = data.trim().split(/\s+/);
              const controller = parts[parts.length - 2];
              const eventName = parts[parts.length - 1];
              if (controller === this.channel) {
                if (eventName === 'ARCHIVE_COMPLETE') {
                  archiveFinished();
                } else if (eventName === 'RESTORE_COMPLETE') {
                  restoreFinished();
                }
              }
            }
          }
        } catch (err) {
          console.error('WS message error', err);
        }
      };
      this.ws.onerror = (err) => {
        console.error('WebSocket error', err);
      };
      this.ws.onclose = () => {
        this.ws = null;
        if (this.shouldReconnect) {
          window.setTimeout(() => this.connect(), 5000);
        }
      };
    }

    disconnect() {
      if (this.ws) {
        this.shouldReconnect = false;
        this.ws.close();
        this.ws = null;
      }
    }
  }

  function appendStatus(message) {
    if (!message || !statusLog) {
      return;
    }
    if (!statusLogMessages.length && statusLog.textContent) {
      statusLogMessages = statusLog.textContent.split('\n');
      if (statusLogMessages[statusLogMessages.length - 1] === '') {
        statusLogMessages.pop();
      }
    }
    const text = typeof message === 'string' ? message : String(message);
    statusLogMessages.push(text);
    if (statusLogMessages.length > MAX_STATUS_MESSAGES) {
      statusLogMessages.splice(0, statusLogMessages.length - MAX_STATUS_MESSAGES);
    }
    statusLog.textContent = statusLogMessages.length ? `${statusLogMessages.join('\n')}\n` : '';
    statusLog.scrollTop = statusLog.scrollHeight;
  }

  function formatBytes(bytes) {
    if (!bytes) return '0 B';
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    const value = bytes / Math.pow(1024, i);
    return `${value.toFixed(value >= 10 || i === 0 ? 0 : 1)} ${units[i]}`;
  }

  function renderArchiveRow(item) {
    const tr = document.createElement('tr');

    const nameTd = tr.insertCell();
    nameTd.textContent = item.name;

    const commentTd = tr.insertCell();
    commentTd.textContent = item.comment || '';

    const sizeTd = tr.insertCell();
    sizeTd.textContent = formatBytes(item.size || 0);

    const modTd = tr.insertCell();
    modTd.textContent = item.modified || '';

    const linkTd = tr.insertCell();
    const link = document.createElement('a');
    link.href = item.download_url;
    link.textContent = 'Download';
    link.rel = 'nofollow';
    link.target = '_blank';
    link.className = 'pure-button pure-button-secondary';
    linkTd.appendChild(link);

    const restoreTd = tr.insertCell();
    const restoreBtn = document.createElement('button');
    restoreBtn.type = 'button';
    restoreBtn.className = 'pure-button pure-button-secondary';
    restoreBtn.textContent = 'Restore';
    restoreBtn.dataset.role = 'restore';
    restoreBtn.addEventListener('click', () => requestRestore(item.name));
    if (isUserAnonymous) {
      restoreBtn.disabled = true;
      restoreBtn.title = 'Restore is only available for authorized users.';
    }
    restoreTd.appendChild(restoreBtn);

    const deleteTd = tr.insertCell();
    const deleteBtn = document.createElement('button');
    deleteBtn.type = 'button';
    deleteBtn.className = 'pure-button pure-button-secondary';
    deleteBtn.textContent = 'Delete';
    deleteBtn.dataset.role = 'delete';
    deleteBtn.addEventListener('click', () => requestDelete(item.name));
    if (isUserAnonymous) {
      deleteBtn.disabled = true;
      deleteBtn.title = 'Delete is only available for authorized users.';
    }
    deleteTd.appendChild(deleteBtn);

    return tr;
  }

  function populateArchiveTable(data) {
    tableBody.innerHTML = '';
    const archives = (data && data.archives) || [];
    if (!archives.length) {
      archiveEmpty.hidden = false;
    } else {
      archiveEmpty.hidden = true;
      archives.forEach((item) => {
        tableBody.appendChild(renderArchiveRow(item));
      });
    }

    if (data && data.in_progress) {
      archiveButton.disabled = true;
      currentJobId = data.job_id || null;
      setRestoreButtonsDisabled(true);
      setDeleteButtonsDisabled(true);
    } else if (!currentJobId) {
      archiveButton.disabled = false;
      setRestoreButtonsDisabled(false);
      setDeleteButtonsDisabled(false);
    }
  }

  function fetchArchives() {
    return fetch(archivesUrl, { cache: 'no-store' })
      .then((response) => {
        if (!response.ok) throw new Error('Failed to fetch archives');
        return response.json();
      })
      .then(populateArchiveTable)
      .catch((err) => console.error(err));
  }

  function archiveFinished() {
    currentJobId = null;
    archiveButton.disabled = false;
    setRestoreButtonsDisabled(false);
    setDeleteButtonsDisabled(false);
    if (commentInput) {
      commentInput.value = '';
    }
    fetchArchives();
  }

  function startArchive() {
    archiveButton.disabled = true;
    setRestoreButtonsDisabled(true);
    setDeleteButtonsDisabled(true);
    let comment = '';
    if (commentInput) {
      comment = (commentInput.value || '').trim();
      if (comment.length > 40) {
        comment = comment.slice(0, 40);
        commentInput.value = comment;
      }
    }
    appendStatus('Submitting archive job...');
    fetch(archiveApiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ comment })
    })
      .then((response) => response.json())
      .then((body) => {
        if (!body.Success) {
          throw new Error(body.Error || 'Archive submission failed');
        }
        currentJobId = body.job_id;
        appendStatus(`Archive job submitted: ${currentJobId}`);
      })
      .catch((err) => {
        appendStatus(`ERROR: ${err.message || err}`);
        archiveButton.disabled = false;
        setRestoreButtonsDisabled(false);
        setDeleteButtonsDisabled(false);
      });
  }

  function requestRestore(name) {
    if (!name) {
      return;
    }
    const confirmed = window.confirm(`Restore archive "${name}"?\nThis replaces current project files.`);
    if (!confirmed) {
      return;
    }
    startRestore(name);
  }

  function startRestore(name) {
    archiveButton.disabled = true;
    setRestoreButtonsDisabled(true);
    setDeleteButtonsDisabled(true);
    appendStatus(`Submitting restore job for ${name}...`);
    restoreLink.innerHTML = '';
    fetch(restoreApiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ archive_name: name })
    })
      .then((response) => response.json())
      .then((body) => {
        if (!body.Success) {
          throw new Error(body.Error || 'Restore submission failed');
        }
        currentJobId = body.job_id;
        appendStatus(`Restore job submitted: ${currentJobId}`);
      })
      .catch((err) => {
        appendStatus(`ERROR: ${err.message || err}`);
        if (!currentJobId) {
          archiveButton.disabled = false;
          setRestoreButtonsDisabled(false);
          setDeleteButtonsDisabled(false);
        }
      });
  }

  function restoreFinished() {
    currentJobId = null;
    archiveButton.disabled = false;
    setRestoreButtonsDisabled(false);
    setDeleteButtonsDisabled(false);
    fetchArchives();
    restoreLink.innerHTML = '';
    const link = document.createElement('a');
    link.href = projectPath;
    link.textContent = `Load ${runid} Project`;
    link.className = 'pure-button pure-button-secondary';
    restoreLink.appendChild(link);
  }

  function requestDelete(name) {
    if (!name) {
      return;
    }
    const confirmed = window.confirm(`Delete archive "${name}"? This cannot be undone.`);
    if (!confirmed) {
      return;
    }
    startDelete(name);
  }

  function startDelete(name) {
    setDeleteButtonsDisabled(true);
    appendStatus(`Deleting archive ${name}...`);
    fetch(deleteApiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ archive_name: name })
    })
      .then((response) => response.json())
      .then((body) => {
        if (!body.Success) {
          throw new Error(body.Error || 'Delete failed');
        }
        fetchArchives();
      })
      .catch((err) => {
        appendStatus(`ERROR: ${err.message || err}`);
      })
      .finally(() => {
        if (!currentJobId) {
          setRestoreButtonsDisabled(false);
          setDeleteButtonsDisabled(false);
        }
      });
  }

  function setRestoreButtonsDisabled(disabled) {
    document.querySelectorAll('button[data-role="restore"]').forEach((btn) => {
      if (isUserAnonymous) {
        btn.disabled = true;
      } else {
        btn.disabled = disabled;
      }
    });
  }

  function setDeleteButtonsDisabled(disabled) {
    document.querySelectorAll('button[data-role="delete"]').forEach((btn) => {
      if (isUserAnonymous) {
        btn.disabled = true;
      } else {
        btn.disabled = disabled;
      }
    });
  }

  document.addEventListener('DOMContentLoaded', () => {
    const projectLabel = document.getElementById('project_label');
    if (projectLabel) {
      projectLabel.textContent = 'Create and manage project archives.';
    }
    archiveButton.addEventListener('click', startArchive);
    refreshButton.addEventListener('click', fetchArchives);
    fetchArchives();
    const wsClient = new WSClient(runid, 'archive');
    wsClient.connect();
  });
})();
</script>
{% endblock %}
