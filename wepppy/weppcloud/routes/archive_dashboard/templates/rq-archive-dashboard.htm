{% extends "base_pure.htm" %}

{% block title %}Archive Dashboard â€“ {{ runid }}{% endblock %}

{% from "shared/console_macros.htm" import console_page, console_header, button_row %}
{% import "controls/_pure_macros.html" as ui %}

{% block body %}
{% call console_page(data_controller="archive-dashboard") %}
  {% call console_header(
    run_link=url_for_run('run_0.runs0', runid=runid, config=config),
    run_label=runid,
    title="Archive Dashboard"
  ) %}
    <p id="project_label" class="wc-text-muted">Create and manage project archives.</p>
  {% endcall %}

  <section class="wc-stack">
    {% call ui.control_shell(
         form_id="archive_form",
         title="Create Archive",
         collapsible=False,
         form_attrs={'novalidate': True},
         status_panel_override=ui.status_panel(
           id="archive_status_panel",
           title="Archive status",
           variant="console",
           description="Live updates for archive and restore jobs.",
           log_id="archive_status_log",
           initial="Waiting for activity..."
         ),
         summary_panel_override='',
         stacktrace_panel_override=ui.stacktrace_panel(
           id="archive_stacktrace_panel",
           summary="Stack trace",
           description="Latest exception details from archive jobs.",
           empty_state="No stack trace recorded."
         )
       ) %}
      <fieldset>
        {{ ui.text_field(
             'archive_comment',
             'Archive comment',
             help='Optional note stored with the archive.',
             attrs={
               'maxlength': '40',
               'placeholder': 'Optional note stored with the archive'
             }
           ) }}
        {% call button_row() %}
          <button type="button" class="pure-button" id="archive_button">Create archive</button>
          <button type="button" class="pure-button pure-button-secondary" id="refresh_button">Refresh list</button>
        {% endcall %}
      </fieldset>
    {% endcall %}
  </section>

  <section class="wc-stack">
    {% call ui.control_shell(
         form_id="archive_list",
         title="Existing Archives",
         collapsible=False,
         status_panel_override='',
         stacktrace_panel_override='',
         summary_panel_override='',
       ) %}
      <p id="archive_empty" class="wc-text-muted" hidden>No archives available.</p>
      <div class="wc-table-wrapper">
        <table class="wc-table" id="archives_table" aria-describedby="archive_empty">
          <thead>
            <tr>
              <th scope="col">Name</th>
              <th scope="col">Comment</th>
              <th scope="col">Size</th>
              <th scope="col">Created</th>
              <th scope="col">Download</th>
              <th scope="col">Restore</th>
              <th scope="col">Delete</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div id="restore_link" class="wc-inline"></div>
    {% endcall %}
  </section>
{% endcall %}
{% endblock %}


{% block script_extras %}
<script src="{{ url_for('static', filename='vendor/jquery/jquery.js') }}"></script>
<script src="{{ url_for('static', filename='js/controllers.js') }}"></script>
<script>
(function () {
  const runid = {{ runid | tojson }};
  const config = {{ config | tojson }};
  const archivesUrl = {{ url_for_run('archive.rq_archive_list', runid=runid, config=config) | tojson }};
  const archiveApiUrl = {{ url_for_run('rq_api.api_archive', runid=runid, config=config) | tojson }};
  const restoreApiUrl = {{ url_for_run('rq_api.api_restore_archive', runid=runid, config=config) | tojson }};
  const deleteApiUrl = {{ url_for_run('rq_api.api_delete_archive', runid=runid, config=config) | tojson }};
  const projectPath = {{ url_for_run('run_0.runs0', runid=runid, config=config) | tojson }};
  const isUserAnonymous = {{ user.is_anonymous | tojson }};
  const MAX_STATUS_MESSAGES = 3000;

  let currentJobId = null;
  let statusStream = null;

  const pendingStatusMessages = [];

  let statusLog;
  let archiveEmpty;
  let archiveButton;
  let refreshButton;
  let commentInput;
  let restoreLink;
  let tableBody;
  let stacktracePanel;

  function appendStatus(message) {
    if (message === undefined || message === null) {
      return;
    }
    const text = typeof message === 'string' ? message : String(message);
    if (statusStream) {
      statusStream.append(text);
    } else {
      pendingStatusMessages.push(text);
      if (pendingStatusMessages.length > MAX_STATUS_MESSAGES) {
        pendingStatusMessages.splice(0, pendingStatusMessages.length - MAX_STATUS_MESSAGES);
      }
      if (statusLog) {
        statusLog.textContent = `${pendingStatusMessages.join('\n')}\n`;
        statusLog.scrollTop = statusLog.scrollHeight;
      }
    }
  }

  function flushPendingStatus() {
    if (!statusStream || pendingStatusMessages.length === 0) {
      return;
    }
    pendingStatusMessages.splice(0).forEach((msg) => statusStream.append(msg));
  }

  function handleTrigger(detail) {
    if (!detail || !detail.event) {
      return;
    }
    const eventName = String(detail.event).toUpperCase();
    if (eventName === 'ARCHIVE_COMPLETE') {
      archiveFinished();
    } else if (eventName === 'RESTORE_COMPLETE') {
      restoreFinished();
    }
  }

  function formatBytes(bytes) {
    if (!bytes) return '0 B';
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    const value = bytes / Math.pow(1024, i);
    return `${value.toFixed(value >= 10 || i === 0 ? 0 : 1)} ${units[i]}`;
  }

  function renderArchiveRow(item) {
    const tr = document.createElement('tr');

    const nameTd = tr.insertCell();
    nameTd.textContent = item.name;

    const commentTd = tr.insertCell();
    commentTd.textContent = item.comment || '';

    const sizeTd = tr.insertCell();
    sizeTd.textContent = formatBytes(item.size || 0);

    const modTd = tr.insertCell();
    modTd.textContent = item.modified || '';

    const linkTd = tr.insertCell();
    const link = document.createElement('a');
    link.href = item.download_url;
    link.textContent = 'Download';
    link.rel = 'nofollow';
    link.target = '_blank';
    link.className = 'pure-button pure-button-secondary';
    linkTd.appendChild(link);

    const restoreTd = tr.insertCell();
    const restoreBtn = document.createElement('button');
    restoreBtn.type = 'button';
    restoreBtn.className = 'pure-button pure-button-secondary';
    restoreBtn.textContent = 'Restore';
    restoreBtn.dataset.role = 'restore';
    restoreBtn.addEventListener('click', () => requestRestore(item.name));
    if (isUserAnonymous) {
      restoreBtn.disabled = true;
      restoreBtn.title = 'Restore is only available for authorized users.';
    }
    restoreTd.appendChild(restoreBtn);

    const deleteTd = tr.insertCell();
    const deleteBtn = document.createElement('button');
    deleteBtn.type = 'button';
    deleteBtn.className = 'pure-button pure-button-secondary';
    deleteBtn.textContent = 'Delete';
    deleteBtn.dataset.role = 'delete';
    deleteBtn.addEventListener('click', () => requestDelete(item.name));
    if (isUserAnonymous) {
      deleteBtn.disabled = true;
      deleteBtn.title = 'Delete is only available for authorized users.';
    }
    deleteTd.appendChild(deleteBtn);

    return tr;
  }

  function populateArchiveTable(data) {
    if (!tableBody) {
      return;
    }
    tableBody.innerHTML = '';
    const archives = (data && data.archives) || [];
    if (!archives.length) {
      if (archiveEmpty) {
        archiveEmpty.hidden = false;
      }
    } else {
      if (archiveEmpty) {
        archiveEmpty.hidden = true;
      }
      archives.forEach((item) => {
        tableBody.appendChild(renderArchiveRow(item));
      });
    }

    if (data && data.in_progress) {
      if (archiveButton) {
        archiveButton.disabled = true;
      }
      currentJobId = data.job_id || null;
      setRestoreButtonsDisabled(true);
      setDeleteButtonsDisabled(true);
    } else if (!currentJobId) {
      if (archiveButton) {
        archiveButton.disabled = false;
      }
      setRestoreButtonsDisabled(false);
      setDeleteButtonsDisabled(false);
    }
  }

  function fetchArchives() {
    return fetch(archivesUrl, { cache: 'no-store' })
      .then((response) => {
        if (!response.ok) throw new Error('Failed to fetch archives');
        return response.json();
      })
      .then(populateArchiveTable)
      .catch((err) => console.error(err));
  }

  function archiveFinished() {
    currentJobId = null;
    if (archiveButton) {
      archiveButton.disabled = false;
    }
    setRestoreButtonsDisabled(false);
    setDeleteButtonsDisabled(false);
    if (commentInput) {
      commentInput.value = '';
    }
    appendStatus('Archive job completed.');
    fetchArchives();
  }

  function startArchive() {
    if (archiveButton) {
      archiveButton.disabled = true;
    }
    setRestoreButtonsDisabled(true);
    setDeleteButtonsDisabled(true);
    let comment = '';
    if (commentInput) {
      comment = (commentInput.value || '').trim();
      if (comment.length > 40) {
        comment = comment.slice(0, 40);
        commentInput.value = comment;
      }
    }
    appendStatus('Submitting archive job...');
    fetch(archiveApiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ comment })
    })
      .then((response) => response.json())
      .then((body) => {
        if (!body.Success) {
          throw new Error(body.Error || 'Archive submission failed');
        }
        currentJobId = body.job_id;
        appendStatus(`Archive job submitted: ${currentJobId}`);
      })
      .catch((err) => {
        appendStatus(`ERROR: ${err.message || err}`);
        if (archiveButton) {
          archiveButton.disabled = false;
        }
        setRestoreButtonsDisabled(false);
        setDeleteButtonsDisabled(false);
      });
  }

  function requestRestore(name) {
    if (!name) {
      return;
    }
    const confirmed = window.confirm(`Restore archive "${name}"?
This replaces current project files.`);
    if (!confirmed) {
      return;
    }
    startRestore(name);
  }

  function startRestore(name) {
    if (archiveButton) {
      archiveButton.disabled = true;
    }
    setRestoreButtonsDisabled(true);
    setDeleteButtonsDisabled(true);
    appendStatus(`Submitting restore job for ${name}...`);
    if (restoreLink) {
      restoreLink.innerHTML = '';
    }
    fetch(restoreApiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ archive_name: name })
    })
      .then((response) => response.json())
      .then((body) => {
        if (!body.Success) {
          throw new Error(body.Error || 'Restore submission failed');
        }
        currentJobId = body.job_id;
        appendStatus(`Restore job submitted: ${currentJobId}`);
      })
      .catch((err) => {
        appendStatus(`ERROR: ${err.message || err}`);
        if (!currentJobId && archiveButton) {
          archiveButton.disabled = false;
        }
        setRestoreButtonsDisabled(false);
        setDeleteButtonsDisabled(false);
      });
  }

  function restoreFinished() {
    currentJobId = null;
    if (archiveButton) {
      archiveButton.disabled = false;
    }
    setRestoreButtonsDisabled(false);
    setDeleteButtonsDisabled(false);
    fetchArchives();
    appendStatus('Restore job completed.');
    if (restoreLink) {
      restoreLink.innerHTML = '';
      const link = document.createElement('a');
      link.href = projectPath;
      link.textContent = `Load ${runid} Project`;
      link.className = 'pure-button pure-button-secondary';
      restoreLink.appendChild(link);
    }
  }

  function requestDelete(name) {
    if (!name) {
      return;
    }
    const confirmed = window.confirm(`Delete archive "${name}"? This cannot be undone.`);
    if (!confirmed) {
      return;
    }
    startDelete(name);
  }

  function startDelete(name) {
    setDeleteButtonsDisabled(true);
    appendStatus(`Deleting archive ${name}...`);
    fetch(deleteApiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ archive_name: name })
    })
      .then((response) => response.json())
      .then((body) => {
        if (!body.Success) {
          throw new Error(body.Error || 'Delete failed');
        }
        fetchArchives();
      })
      .catch((err) => {
        appendStatus(`ERROR: ${err.message || err}`);
      })
      .finally(() => {
        if (!currentJobId) {
          setRestoreButtonsDisabled(false);
          setDeleteButtonsDisabled(false);
        }
      });
  }

  function setRestoreButtonsDisabled(disabled) {
    document.querySelectorAll('button[data-role="restore"]').forEach((btn) => {
      if (isUserAnonymous) {
        btn.disabled = true;
      } else {
        btn.disabled = disabled;
      }
    });
  }

  function setDeleteButtonsDisabled(disabled) {
    document.querySelectorAll('button[data-role="delete"]').forEach((btn) => {
      if (isUserAnonymous) {
        btn.disabled = true;
      } else {
        btn.disabled = disabled;
      }
    });
  }

  function initStatusStream() {
    if (typeof StatusStream === 'undefined') {
      console.error('StatusStream module is unavailable.');
      return;
    }
    const panel = document.getElementById('archive_status_panel');
    if (!panel) {
      return;
    }
    const stacktrace = stacktracePanel ? { element: stacktracePanel } : null;
    if (statusStream) {
      statusStream.disconnect();
    }
    statusStream = StatusStream.attach({
      element: panel,
      channel: 'archive',
      runId: runid,
      logLimit: MAX_STATUS_MESSAGES,
      stacktrace,
      onTrigger: handleTrigger
    });
    panel.addEventListener('status:error', (event) => {
      if (event && event.detail && event.detail.error) {
        console.error('Archive status stream error:', event.detail.error);
      }
    });
    flushPendingStatus();
  }

  document.addEventListener('DOMContentLoaded', () => {
    const projectLabel = document.getElementById('project_label');
    if (projectLabel) {
      projectLabel.textContent = 'Create and manage project archives.';
    }
    archiveEmpty = document.getElementById('archive_empty');
    archiveButton = document.getElementById('archive_button');
    refreshButton = document.getElementById('refresh_button');
    commentInput = document.getElementById('archive_comment');
    restoreLink = document.getElementById('restore_link');
    tableBody = document.querySelector('#archives_table tbody');
    stacktracePanel = document.getElementById('archive_stacktrace_panel');
    if (stacktracePanel) {
      stacktracePanel.hidden = true;
    }
    statusLog = document.getElementById('archive_status_log');

    if (archiveButton) {
      archiveButton.addEventListener('click', startArchive);
    }
    if (refreshButton) {
      refreshButton.addEventListener('click', fetchArchives);
    }

    initStatusStream();
    fetchArchives();
  });
})();
</script>
{% endblock %}
