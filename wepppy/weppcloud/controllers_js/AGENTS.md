# controllers_js Agent Playbook

> Audience: AI coding agents working inside `wepppy/weppcloud/controllers_js/`.

## Mission Snapshot
- Maintain the run-controller bundle that powers WEPPcloud dashboards.
- Keep every controller aligned with the modernization program (helpers, unified payloads, documented contracts).
- Ensure the bundle build pipeline (`build_controllers_js.py`) and Jest suite stay green after every change.

## Foundations (read before coding)
See `docs/dev-notes/controller_foundations.md` for the canonical vision. Key pillars:
- **Shared UI primitives**: structure markup around `data-*` hooks so `WCDom`/`WCEvents` manage toggles, buttons, and lifecycle events consistently.
- **Unified payload schemas**: every controller/route pair runs through `parse_request_payload`; NoDb `parse_inputs` now expect native booleans/ints/floats (never `"on"` strings). Keep per-domain docs up to date.
- **Evolving `controlBase`**: treat it as the declarative job runner—prefer its lifecycle events (`job:started`, `job:completed`, `job:error`) over ad-hoc polling.
- **Telemetry via StatusStream**: all controllers must use `controlBase.attach_status_stream`; `WSClient` is gone and should not be reintroduced.
- **Documentation alignment**: when you add primitives or change payloads/events, update `controllers_js/README.md`, this playbook, and the domain contract doc.
- **Tooling expectations**: lint (`wctl run-npm lint`), test (`wctl run-npm test`), rebuild bundle, and run targeted pytest suites before handoff. Add Jest coverage when primitives or controller patterns evolve.

> Controllers should focus on domain logic while helpers + documented contracts handle the boilerplate. If you find yourself re-implementing plumbing, improve the shared primitives instead.

## Primary Assets
- Helpers: `dom.js`, `events.js`, `forms.js`, `http.js` (global namespaces exposed via IIFEs).
- Infrastructure: `control_base.js`, `status_stream.js`, `unitizer_client.js`.
- Controllers: one file per control (`project.js`, `path_ce.js`, etc.).
- Template: `templates/controllers.js.j2` (rendered by `build_controllers_js.py`).
- Tests: `__tests__/` directory (Jest, jsdom environment).

## Standard Workflow
Follow `docs/dev-notes/module_refactor_workflow.md` for end-to-end instructions. Highlights:
1. **Scope**: audit jQuery usage, templates, backend routes, and domain documentation before editing.
2. **Plan**: decide which helpers (`WCDom`, `WCForms`, `WCHttp`, `WCEvents`, `controlBase`) you need and whether payloads switch to JSON.
3. **Implement**:
   - Use helper namespaces instead of direct DOM APIs; keep controllers wrapped in IIFEs that attach to `window`.
   - Update paired Flask routes in the same change using `parse_request_payload`; normalize booleans/arrays and adjust NoDb methods to read native types.
   - Remove inline jQuery bootstrap from templates; rely on module-level init or `DOMContentLoaded`.
4. **Document**: update `README.md`, this playbook, and any domain contract doc when behavior or payloads change.
5. **Validate**:
   - `wctl run-npm lint`, `wctl run-npm test` (or `wctl run-npm check`)
   - `python wepppy/weppcloud/controllers_js/build_controllers_js.py`
   - `wctl run-pytest tests/weppcloud/...` (targeted) and `wctl run-pytest tests --maxfail=1` when broad changes land.
   - Manual smoke test in the dev environment when practical.

## Controller Migration Tips
- Replace `$(selector)` with `WCDom.qs/qsa`, `delegate` for event delegation, and `toggle/hide/show` for visibility flips.
- Swap `$.ajax` or `$.get` with `WCHttp.request/getJson/postForm`.
- Use `WCForms.serializeForm` instead of `form.serialize()` and `WCForms.applyValues` for hydration.
- When controllers need event buses, prefer `WCEvents.createEmitter` or `WCEvents.emitDom`; `wepp.js` now emits `wepp:run:*` and `wepp:report:loaded` so neighbouring modules subscribe without polling DOM state.
- After refactoring, search for leftover `$(` in the module to ensure the jQuery dependency was removed.

### Project controller reference
- DOM hooks live on `data-project-field`, `data-project-toggle`, `data-project-action`, and `data-project-unitizer`. When the UI grows, add new `data-*` attributes and wire them through `WCDom.delegate` rather than binding inline handlers.
- `Project.getInstance().events` exposes a `WCEvents` emitter. Emitters currently surface `project:name:*`, `project:scenario:*`, `project:readonly:*`, `project:public:*`, and `project:unitizer:*` lifecycle events—subscribe instead of reading private state like `_currentName`.
- Unitizer integration now posts JSON payloads to `/tasks/set_unit_preferences/` and the backend returns the persisted preferences in `Content.preferences`. The global `window.setGlobalUnitizerPreference` helper simply forwards to `Project.handleGlobalUnitPreference`, so external scripts continue to function.
- Jest coverage for the controller lives in `__tests__/project.test.js`. When events, payloads, or data hooks change, expand that suite alongside template updates to lock in behaviour.

### Climate controller reference
- DOM hooks rely on `data-climate-action`, `data-climate-section`, and `data-precip-section` attributes plus the JSON seed embedded in `#climate_catalog_data`. Keep templates free of inline `on*` handlers—delegate through the controller instead.
- `Climate.getInstance().events` wraps `WCEvents.useEventMap` and currently publishes `climate:dataset:changed`, `climate:dataset:mode`, `climate:station:mode`, `climate:station:selected`, `climate:station:list:loading`, `climate:station:list:loaded`, `climate:build:started`, `climate:build:completed`, `climate:build:failed`, `climate:precip:mode`, `climate:upload:completed`, `climate:upload:failed`, and `climate:gridmet:updated`. Use these signals for dashboards and downstream automation.
- Network flows run through `WCHttp.postJson`/`request`; paired Flask routes now call `parse_request_payload` so JSON and form submissions behave the same. Update `wepppy/weppcloud/routes/nodb_api/climate_bp.py` alongside controller changes.
- Jest coverage lives in `controllers_js/__tests__/climate.test.js`; pytest coverage for the routes sits in `tests/weppcloud/routes/test_climate_bp.py`. Run both suites when editing climate code: `wctl run-npm test -- climate` (or the full suite) and `wctl run-pytest tests/weppcloud/routes/test_climate_bp.py`.
- After touching the controller, rebuild the bundle with `python wepppy/weppcloud/controllers_js/build_controllers_js.py` so the dev container picks up changes before you reload the UI.
- **Map controller**: `map_pure.htm` uses `data-map-action="go|find-topaz|find-wepp"` on toolbar buttons while keeping `#mapstatus`, `#mouseelev`, `#drilldown`, `#sub_legend`, and `#sbs_legend` for helper-based updates. `MapController.getInstance().events = WCEvents.useEventMap([...])` emits `map:ready`, `map:center:requested`, `map:center:changed`, `map:search:requested`, `map:elevation:requested`, `map:elevation:loaded`, `map:elevation:error`, `map:drilldown:requested`, `map:drilldown:loaded`, `map:drilldown:error`, `map:layer:toggled`, `map:layer:refreshed`, and `map:layer:error`. Subscribe to those signals (instead of scraping DOM) whenever neighbouring controls react to viewport, drilldown, or overlay state.

### Subcatchment controller reference
- Markup now uses `data-subcatchment-action="build"` on the command button and `data-subcatchment-role` (`cmap-option`, `scale-range`) on radios/sliders. Avoid resurrecting inline `onclick` handlers—delegate through `WCDom`.
- `SubcatchmentDelineation.getInstance().events = WCEvents.useEventMap([...])` exposes `subcatchment:build:started`, `subcatchment:build:completed`, `subcatchment:build:error`, `subcatchment:map:mode`, and `subcatchment:legend:updated`. The controller still forwards `BUILD_SUBCATCHMENTS_TASK_COMPLETED` and `WATERSHED_ABSTRACTION_TASK_COMPLETED` through `triggerEvent` so Channel/WEPP integrations stay intact.
- Build requests post JSON with `WCHttp.postJson("rq/api/build_subcatchments_and_abstract_watershed", WCForms.serializeForm(form, { format: "json" }))`. The Flask route runs through `parse_request_payload`, converting booleans (`clip_hillslopes`, `walk_flowpaths`, `mofe_buffer`, `bieger2015_widths`) and floats before mutating the `Watershed` singleton and queueing RQ work.
- Keep tests updated: `controllers_js/__tests__/subcatchment_delineation.test.js` (jsdom) exercises build submission, delegated map toggles, and error propagation; `tests/weppcloud/routes/test_rq_api_subcatchments.py` (pytest) covers RedisPrep/queue wiring and batch short-circuiting. Run them with the standard `wctl run-npm test` / `wctl run-pytest tests/weppcloud/routes/test_rq_api_subcatchments.py` cadence and rebuild the bundle afterwards.

### Ash controller reference
- DOM hooks rely on `data-ash-*` attributes (`data-ash-depth-mode`, `data-ash-action`, `data-ash-upload`) plus the JSON seed in `#ash-model-params-data`. Remove inline `on*` handlers—delegate through `WCDom`.
- `Ash.getInstance().events = WCEvents.useEventMap([...])` emits `ash:mode:changed`, `ash:model:changed`, `ash:transport:mode`, `ash:run:started`, `ash:run:completed`, and `ash:model:values:capture`. Emit new signals instead of mutating controller internals so dashboards can subscribe cleanly.
- The `/rq/api/run_ash` route now runs everything through `parse_request_payload` and `Ash.parse_inputs` consumes native booleans/ints/floats. Keep routes and NoDb signatures aligned when payloads evolve.
- Lint/test cadence: `wctl run-npm lint`, `wctl run-npm test -- ash`, `python wepppy/weppcloud/controllers_js/build_controllers_js.py`, and `wctl run-pytest tests/weppcloud/routes/test_rq_api_ash.py`. The Jest suite exercises depth-mode toggles, cache persistence, run submission, and error handling; pytest covers payload normalisation and RQ enqueue logic.

### Landuse Modify controller reference
- DOM hooks now live on `data-landuse-modify-action="toggle-selection|submit"` and `data-landuse-modify-field="topaz-ids|landuse-code"` inside `modify_landuse.htm`. Selection mode relies on delegated listeners (`WCDom.delegate`) plus Leaflet overlays from `MapController`; add future map behaviours through helper-friendly data attributes rather than inline scripts.
- Events: `LanduseModify.getInstance().events = WCEvents.useEventMap(['landuse:modify:started', 'landuse:modify:completed', 'landuse:modify:error', 'landuse:selection:changed', 'job:started', 'job:completed', 'job:error'])`. Subscribe to these topics (or the inherited `controlBase` lifecycle events) instead of inspecting internal sets when other modules need to react to landuse updates.
- Transport: modification submissions post JSON to `tasks/modify_landuse/` (`{ topaz_ids: [...], landuse: '<code>' }`) via `WCHttp.postJson`. Rectangle selections call `tasks/sub_intersection/` with a JSON extent; the Flask route now normalises IDs through `_coerce_topaz_ids` / `_coerce_landuse_code`. Keep payload schemas documented in `docs/work-packages/20251023_controller_modernization/notes/archived-plans/landuse-modify-controller-plan.md` when they evolve.
- Testing: Jest coverage (`controllers_js/__tests__/landuse_modify.test.js`) exercises selection toggles, event emission, and error handling with stubbed MapController/Leaflet helpers. Backend behaviour is locked down in `tests/weppcloud/routes/test_landuse_bp.py`—run those alongside `wctl run-npm test` and `wctl run-pytest tests/weppcloud/routes/test_landuse_bp.py tests/weppcloud/routes/test_rq_api_landuse.py` during refactors.

### Omni controller reference
- DOM hooks now rely on `data-omni-action` (`add-scenario`, `run-scenarios`), delegated scenario selectors tagged with `data-omni-role="scenario-select"`, and per-row containers marked `data-omni-scenario-controls`. Templates no longer ship inline scripts—let the controller render scenario cards dynamically and document any new `data-omni-*` hooks when requirements change.
- `Omni.getInstance().events = WCEvents.useEventMap([...])` publishes `omni:scenario:added`, `omni:scenario:removed`, `omni:scenario:updated`, `omni:scenarios:loaded`, `omni:run:started`, `omni:run:completed`, and `omni:run:error`. Subscribe to these lifecycle signals instead of reading internal state when other controls (status panels, unitizer) need to react.
- Scenario submissions build a `FormData` payload containing `scenarios` JSON plus optional SBS uploads; backend routes `/rq/api/run_omni` and `/rq/api/run_omni_contrasts` call `parse_request_payload` so JSON and multipart submissions share one parser. SBS files stage in `omni/_limbo/{idx}` via `save_run_file`, and payloads hydrate `Omni.parse_scenarios` with native values (no `"on"` strings).
- Validation happens client-side for SBS uploads (allowed extensions + 100 MB cap) before hitting the network; failures emit `omni:run:error` and surface in the legacy status area via `controlBase`.
- Testing cadence: `wctl run-npm lint`, `wctl run-npm test -- omni`, `python wepppy/weppcloud/controllers_js/build_controllers_js.py`, and `wctl run-pytest tests/weppcloud/routes/test_rq_api_omni.py`. The Jest suite (`__tests__/omni.test.js`) covers FormData serialization, scenario hydration, and validation; pytest exercises JSON vs multipart payloads, Redis queue wiring, and SBS upload staging.

### Outlet controller reference
- DOM hooks now rely on `data-outlet-root` to scope delegated listeners, `data-outlet-mode-section` for cursor vs entry panels, `data-outlet-entry-field` on the coordinate input, and `data-outlet-action="cursor-toggle|entry-submit"` on mode buttons. Keep markup helper-friendly—no inline handlers or hard-coded `display: none`.
- `Outlet.getInstance().events = WCEvents.useEventMap([...])` emits `outlet:mode:change`, `outlet:cursor:toggle`, `outlet:set:start`, `outlet:set:queued`, `outlet:set:success`, `outlet:set:error`, and `outlet:display:refresh`. Pair these domain events with the `controlBase` lifecycle signals (`job:started`, `job:completed`, `job:error`) for dashboards and dependent controllers.
- Submissions call `WCHttp.request("rq/api/set_outlet", { json: { latitude, longitude }, form })`; the Flask route consumes JSON/form payloads through `parse_request_payload`, normalises floats, clears `RedisPrep` timestamps, and enqueues `set_outlet_rq`.
- Testing cadence mirrors the modernization workflow: `wctl run-npm lint`, `wctl run-npm test -- outlet`, rebuild with `python wepppy/weppcloud/controllers_js/build_controllers_js.py`, and run `wctl run-pytest tests/weppcloud/routes/test_rq_api_outlet.py` (plus the broader suite as needed).

### BAER controller reference
- DOM hooks: radios expose `data-baer-mode` and control panels `#sbs_mode{0,1}_controls`; buttons advertise intent via `data-baer-action="upload|remove|build-uniform|set-firedate|modify-classes|modify-color-map"` plus `data-baer-uniform` (severity) and optional `data-baer-target` selectors. The opacity slider is generated under `#sbs_legend` as `#baer-opacity-slider`.
- Events: `Baer.getInstance().events = WCEvents.useEventMap([...])` publishes `baer:*` topics covering mode changes, SBS uploads/removals/uniform builds, fire-date updates, class/color-map edits, and map visibility (`baer:map:shown|error|opacity`). Combine these with `controlBase` lifecycle events for RQ telemetry.
- Transport: uploads submit `FormData` to `tasks/upload_sbs/`; removals hit `tasks/remove_sbs`; uniform maps call `tasks/build_uniform_sbs/<value>`. JSON endpoints (`tasks/set_firedate/`, `tasks/modify_burn_class`, `tasks/modify_color_map`) flow through `parse_request_payload` so class breaks arrive as ints and nodata tokens stay trimmed. Map previews request `query/baer_wgs_map/` followed by `resources/legends/sbs/`.
- Tests: update `controllers_js/__tests__/baer.test.js` for UI/HTTP behaviour and `tests/weppcloud/routes/test_disturbed_bp.py` for backend parsing. Always run `wctl run-npm lint`, `wctl run-npm test -- baer` (or the full suite), rebuild the bundle, and execute the disturbed blueprint pytest cases when BAER changes land.
- Documentation: capture new payload fields, emitted events, and helper expectations in `docs/work-packages/20251023_controller_modernization/notes/archived-plans/baer-controller-plan.md` alongside this playbook.

### Disturbed controller reference
- DOM hooks: Pure SBS markup now depends on `data-sbs-action`, `data-sbs-uniform`, and `[data-disturbed-action]` plus the legacy hint nodes (`#hint_upload_sbs`, `#hint_remove_sbs`, `#hint_low_sbs`, `#hint_moderate_sbs`, `#hint_high_sbs`). Keep new affordances helper-friendly—no inline handlers.
- Events: `Disturbed.getInstance().events = WCEvents.useEventMap(['disturbed:mode:changed', 'disturbed:sbs:state', 'disturbed:lookup:reset', 'disturbed:lookup:extended', 'disturbed:lookup:error', 'disturbed:upload:started', 'disturbed:upload:completed', 'disturbed:upload:error', 'disturbed:remove:started', 'disturbed:remove:completed', 'disturbed:remove:error', 'disturbed:uniform:started', 'disturbed:uniform:completed', 'disturbed:uniform:error', 'disturbed:firedate:updated', 'disturbed:firedate:error'])`. The controller also dispatches `CustomEvent('disturbed:has_sbs_changed')` for legacy listeners and triggers `controlBase` job events with task IDs prefixed `disturbed:`.
- Transport: lookup resets/extends issue `POST` requests with empty bodies; uniform builds post JSON to `tasks/build_uniform_sbs` (`{"value": int}`) while the `<value>` route remains for older clients; fire dates post JSON to `tasks/set_firedate/`; uploads remain `FormData`; `has_sbs` polls `api/disturbed/has_sbs/`. All routes parse through `parse_request_payload` so downstream code receives native types.
- Tests: front-end coverage in `controllers_js/__tests__/disturbed.test.js`; backend regression in `tests/weppcloud/routes/test_disturbed_bp.py` using `tests/factories.singleton_factory` + `rq_environment`. Run `wctl run-npm lint`, `wctl run-npm test -- disturbed`, rebuild the bundle, `wctl run-pytest tests/weppcloud/routes/test_disturbed_bp.py`, and `wctl run-pytest tests --maxfail=1` when shared modules are touched.

### Debris Flow controller reference
- DOM hooks: the run button in both legacy and pure templates now exposes `data-debris-action="run"` inside `#debris_flow_form`. Add future controls under a `data-debris-*` namespace and rely on `WCDom.delegate` rather than inline handlers.
- Events: `DebrisFlow.getInstance().events = WCEvents.useEventMap(['debris:run:started', 'debris:run:completed', 'debris:run:error'])`. Emit these alongside the `controlBase` lifecycle events (`job:started|completed|error`) whenever runs queue, finish, or fail so dashboards and neighbours stay aligned.
- Transport: submissions call `WCHttp.postJson("rq/api/run_debris_flow", payload)`; the Flask route now runs the body through `parse_request_payload`, coercing optional `clay_pct` / `liquid_limit` floats and an optional `datasource` string before enqueuing `run_debris_flow_rq(runid, payload=…)`. The RQ task forwards the native values to `DebrisFlow.run_debris_flow(cc=…, ll=…, req_datasource=…)`—no more `"on"` checks.
- Tests: frontend coverage in `controllers_js/__tests__/debris_flow.test.js`; backend validation in `tests/weppcloud/routes/test_rq_api_debris_flow.py` and `tests/rq/test_project_rq_debris_flow.py`. During edits run `wctl run-npm lint`, `wctl run-npm test -- debris_flow`, rebuild the bundle, and execute the targeted pytest suites.
- Documentation: `docs/work-packages/20251023_controller_modernization/notes/archived-plans/debris-flow-controller-plan.md` tracks the payload schema, event contracts, and follow-up tasks. Update it alongside this playbook when behaviour changes.

### Observed controller reference
- DOM hooks: both legacy and pure templates expose `#observed_form` with standard status (`#status`), stacktrace (`#stacktrace`), info (`#info`), and job (`#rq_job`) nodes so `controlBase.attach_status_stream` can manage telemetry. The textarea keeps the canonical id/name (`observed_text`) and the run button delegates via `data-action="observed-run"`. The controller toggles visibility on the enclosing `.controller-section`, so avoid reintroducing inline `show()/hide()` calls.
- Transport: submissions call `WCHttp.postJson("tasks/run_model_fit/", { data })`, sourcing `data` from `WCForms.serializeForm(form, { format: "json" })`. Climate completion checks hit `query/climate_has_observed/` through `WCHttp.getJson`, and the Flask route now uses `parse_request_payload(trim_strings=False)` so both JSON and legacy form posts map to the same native string.
- Events: `Observed.getInstance().events = WCEvents.useEventMap(['observed:data:loaded', 'observed:model:fit', 'observed:error', 'job:started', 'job:completed', 'job:error'])`. Listen to `observed:data:loaded` for visibility changes, `observed:model:fit` (`status: 'started'|'completed'`) for workflow telemetry, and `observed:error` for HTTP/validation failures; `controlBase` still emits the `job:*` lifecycle for dashboards.
- Tests: Jest coverage in `controllers_js/__tests__/observed.test.js` exercises delegated wiring, WebSocket lifecycle, success/error handling, and visibility toggles. Backend expectations live in `tests/weppcloud/routes/test_observed_bp.py`, which relies on `tests.factories.singleton_factory` for the NoDb stub. Run `wctl run-npm test -- observed`, rebuild the bundle, and execute the targeted pytest suite whenever this control or its routes change.

### Rangeland Cover controller reference
- DOM hooks: both templates expose helper-first markers—mode radios use `data-rangeland-role="mode"` / `data-rangeland-mode`, the RAP year wrapper is tagged with `data-rangeland-rap-section`, the year input advertises `data-rangeland-input="rap-year"`, and the build button carries `data-rangeland-action="build"`. Keep status, stacktrace, hint, and job nodes inside `#rangeland_cover_form` so `controlBase.attach_status_stream` can hydrate telemetry.
- Transport: mode sync calls `WCHttp.postJson("tasks/set_rangeland_cover_mode/", { mode, rap_year })`; builds post JSON to `tasks/build_rangeland_cover/` with `{ rap_year, defaults: { bunchgrass, forbs, sodgrass, shrub, basal, rock, litter, cryptogams } }`. The paired Flask routes rely on `parse_request_payload`, coerce ints/floats before assigning to NoDb, and still respond with `success_factory()` so older clients stay compatible.
- Events: `RangelandCover.getInstance().events = WCEvents.useEventMap(['rangeland:config:loaded', 'rangeland:mode:changed', 'rangeland:rap-year:changed', 'rangeland:run:started', 'rangeland:run:completed', 'rangeland:run:failed', 'rangeland:report:loaded', 'rangeland:report:failed'])`. The controller also continues to dispatch the legacy `RANGELAND_COVER_BUILD_TASK_COMPLETED` event for Subcatchment integrations—prefer the helper events when wiring dashboards or neighbouring controllers.
- Tests: Jest coverage in `controllers_js/__tests__/rangeland_cover.test.js` exercises helper bootstrap, delegated handlers, lifecycle events, Subcatchment integration, and error propagation. Backend assertions live in `tests/weppcloud/routes/test_rangeland_cover_bp.py`, which leans on `tests.factories.singleton_factory` to validate payload coercion and legacy form fallbacks. Run `wctl run-npm test -- rangeland_cover`, rebuild the bundle, and execute the targeted pytest along with updates to `docs/work-packages/20251023_controller_modernization/notes/archived-plans/rangeland-cover-controller-plan.md` when behaviour changes.

### Rangeland Cover Modify controller reference
- DOM hooks: `modify_rangeland_cover.htm` now tags the modify panel with helper-first markers—`data-rcm-action="toggle-selection"` on the enable checkbox, `data-rcm-action="submit"` on the run button, `data-rcm-field="topaz-ids"` on the textarea, and `data-rcm-field="<measure>"` on each cover input (`bunchgrass`, `forbs`, `sodgrass`, `shrub`, `basal`, `rock`, `litter`, `cryptogams`). Keep status, stacktrace, and job nodes under `#modify_rangeland_cover_form` so `controlBase` stays in charge of telemetry while `WCDom.delegate` owns every interaction.
- Transport: cover summaries post JSON to `query/rangeland_cover/current_cover_summary/` with `{ topaz_ids }`, box selections stream extents to `tasks/sub_intersection/`, and submissions hit `tasks/modify_rangeland_cover/` with `{ topaz_ids, covers }`. The Flask route now uses `parse_request_payload`, normalises/deduplicates Topaz IDs, validates that every cover falls within `0–100`, and surfaces friendly `exception_factory` payloads when validation fails or an unknown ID is supplied; legacy form field names remain supported via fallback lookups.
- Events: `RangelandCoverModify.getInstance().events = WCEvents.useEventMap(['rangeland:modify:loaded', 'rangeland:modify:selection:changed', 'rangeland:modify:run:started', 'rangeland:modify:run:completed', 'rangeland:modify:run:error', 'rangeland:modify:error', 'job:started', 'job:progress', 'job:completed', 'job:error', 'RANGELAND_COVER_MODIFY_TASK_COMPLETED'])`. Subscribe to these helper-first signals for selection, summary, and run lifecycle updates; the legacy DOM event remains for historical listeners, and `controlBase` continues to relay the `job:*` lifecycle.
- Tests: Jest coverage in `controllers_js/__tests__/rangeland_cover_modify.test.js` checks summary hydration, payload composition, event emission, and validation errors. Backend expectations sit in `tests/weppcloud/routes/test_rangeland_cover_bp.py`, confirming Topaz normalisation, range checks, and legacy fallbacks. Run `wctl run-npm test -- rangeland_cover_modify`, rebuild the bundle, execute the targeted pytest, and extend `docs/work-packages/20251023_controller_modernization/notes/archived-plans/rangeland-cover-modify-controller-plan.md` whenever the contract evolves.

### Treatments controller reference
- DOM hooks: `treatments_pure.htm` tags the form with `data-treatments-form`, wires mode radios through `data-treatments-role="mode"` / `data-treatments-mode`, wraps mode-specific stacks with `data-treatments-panel="selection"` / `"upload"`, and exposes `data-treatments-role="selection"`, `"upload"`, `"hint"`, and `"job"` nodes. Lean on these hooks with `WCDom.delegate` instead of restoring inline jQuery; keep status/stacktrace/info nodes inside the form so `controlBase`/StatusStream stay wired in.
- Transport: mode changes call `WCHttp.postJson("tasks/set_treatments_mode/", { mode, single_selection })`. The Flask blueprint now funnels requests through `parse_request_payload`, accepts JSON or legacy form bodies, coerces `mode` to the `TreatmentsMode` enum, and still responds with `success_factory()`. Build submissions continue streaming `FormData` (optional rasters included) to `rq/api/build_treatments`.
- Events: `Treatments.getInstance().events = WCEvents.useEventMap(['treatments:list:loaded', 'treatments:scenario:updated', 'treatments:mode:changed', 'treatments:mode:error', 'treatments:selection:changed', 'treatments:run:started', 'treatments:run:submitted', 'treatments:run:error', 'treatments:job:started', 'treatments:job:completed', 'treatments:job:failed', 'treatments:status:updated'])`. Subscribe to these helper-first emissions instead of scraping DOM text or relying on legacy WebSocket tokens.
- Telemetry: the controller attaches to the `treatments` StatusStream channel via `controlBase.attach_status_stream`, mirroring updates to the DOM, hint, and RQ badge while emitting `treatments:status:updated` payloads for dashboards.
- Tests: add/maintain Jest coverage in `controllers_js/__tests__/treatments.test.js` (bootstrap, delegated mode/selection flows, job orchestration, error handling) and Python coverage in `tests/weppcloud/routes/test_treatments_bp.py` (payload coercion + legacy fallback). Run `wctl run-npm lint`, `wctl run-npm test -- treatments`, rebuild the bundle, and execute the targeted pytest before handoff. Update `docs/work-packages/20251023_controller_modernization/notes/archived-plans/treatments-controller-plan.md` as payloads/events evolve.

### RHEM controller reference
- DOM hooks: the run buttons in `rhem.htm` / `rhem_pure.htm` expose `data-rhem-action="run"`, while status, stacktrace, hint, and job metadata remain inside `#rhem_form` for `controlBase`/`StatusStream`. Optional stage toggles bind to native checkboxes named `clean`, `prep`, and `run` so `WCForms.serializeForm(form, { format: "object" })` emits real booleans.
- Transport: submissions call `WCHttp.postJson("rq/api/run_rhem_rq", WCForms.serializeForm(form, { format: "object" }))`. The Flask route runs the body through `parse_request_payload`, coercing the `clean`, `prep`, and `run` flags before enqueuing `run_rhem_rq(payload=…)`. The RQ task honours those booleans—skipping `clean()`, `prep_hillslopes()`, or `run_hillslopes()` when a flag is `False`—while still publishing StatusStream telemetry.
- Events: `Rhem.getInstance().events = WCEvents.useEventMap(['rhem:config:loaded', 'rhem:run:started', 'rhem:run:queued', 'rhem:run:completed', 'rhem:run:failed', 'rhem:status:updated'])` in addition to the inherited `job:*` lifecycle events from `controlBase`. Prefer these helper-first emissions over parsing DOM status text or legacy WebSocket tokens.
- Telemetry: the controller attaches to `StatusStream` via `controlBase.attach_status_stream`; `rhem.appendStatus` fans updates to both the DOM and event bus so dashboards stay synchronised.
- Tests: add/maintain Jest coverage in `controllers_js/__tests__/rhem.test.js` (bootstrap, delegated actions, lifecycle events, error handling). Backend assertions live in `tests/weppcloud/routes/test_rhem_bp.py` (report/query endpoints) and `tests/weppcloud/routes/test_rq_api_rhem.py` (queue wiring + payload coercion) using the shared RQ + singleton factories. Run `wctl run-npm lint`, `wctl run-npm test -- rhem`, rebuild the bundle, and execute both pytest suites before handoff. Update `docs/work-packages/20251023_controller_modernization/notes/archived-plans/rhem-controller-plan.md` whenever payloads or events change.

### Team controller reference
- DOM hooks: `team.htm` / `team_pure.htm` expose `data-team-action="invite"`/`"remove"` and `data-team-field="email"`; `reports/users.htm` renders collaborator rows with `data-team-user-id` so `WCDom.delegate` can own the removal flow. Keep status, stacktrace, info, hint, and job nodes inside `#team_form` for `controlBase`/StatusStream.
- Transport: invites call `WCHttp.postJson("tasks/adduser/", { email })` (legacy `adduser-email` form payloads still work), removals call `WCHttp.postJson("tasks/removeuser/", { user_id })`. The Flask blueprint runs payloads through `parse_request_payload`, leans on `user_datastore.find_user`, and returns `{ Success: True, Content: { already_member|already_removed } }` for idempotent operations.
- Events: `Team.getInstance().events = WCEvents.useEventMap(['team:list:loading', 'team:list:loaded', 'team:list:failed', 'team:invite:started', 'team:invite:sent', 'team:invite:failed', 'team:member:remove:started', 'team:member:removed', 'team:member:remove:failed', 'team:status:updated'])`. Legacy DOM hooks (`TEAM_ADDUSER_TASK_COMPLETED`, `TEAM_REMOVEUSER_TASK_COMPLETED`) and `job:*` lifecycle triggers still dispatch for historical listeners.
- Tests: add/maintain Jest coverage in `controllers_js/__tests__/team.test.js` (initial load, invite/remove flows, event emission, error handling) and Python coverage in `tests/weppcloud/routes/test_team_bp.py`. Run `wctl run-npm lint`, `wctl run-npm test -- team`, rebuild the bundle, and execute the targeted pytest whenever the Team domain changes.
- Docs: refresh `docs/work-packages/20251023_controller_modernization/notes/archived-plans/team-controller-plan.md` alongside behaviour or payload updates.

- DOM hooks: `rap_ts.htm` and `rap_ts_pure.htm` expose the acquisition button via `data-rap-action="run"` and seed optional schedule metadata in `<script id="rap_ts_schedule_data" data-rap-schedule>`. Keep status, stacktrace, hint, and RQ job nodes under `#rap_ts_form` so `controlBase`/`StatusStream` manage telemetry.
- Events: `RAP_TS.getInstance().events = WCEvents.useEventMap(['rap:schedule:loaded', 'rap:timeseries:run:started', 'rap:timeseries:run:completed', 'rap:timeseries:run:error', 'rap:timeseries:status', 'job:started', 'job:completed', 'job:error'])`. Prefer these helper-first signals (plus the inherited `job:*` lifecycle) over the legacy `RAP_TS_TASK_COMPLETED` DOM trigger when wiring dashboards or neighbouring controllers.
- Transport: job submissions hit `rq/api/acquire_rap_ts` with JSON payloads (`WCForms.serializeForm`). The route parses inputs through `parse_request_payload`, normalises optional `datasets`, `schedule`, and `force_refresh`, then enqueues `fetch_and_analyze_rap_ts_rq(payload=...)` so the worker can log metadata before running the climate-driven acquisition pipeline.
- Tests: add Jest coverage in `controllers_js/__tests__/rap_ts.test.js` for helper bootstrap, lifecycle events, and error handling; backstop the Flask route with `tests/weppcloud/routes/test_rq_api_rap_ts.py` using `tests.factories.rq` + `singleton_factory`. Run `wctl run-npm test -- rap_ts`, rebuild the bundle, execute the targeted pytest, and refresh `docs/work-packages/20251023_controller_modernization/notes/archived-plans/rap-ts-controller-plan.md` whenever behaviour changes.

### Path CE controller reference
- DOM hooks: the pure template exposes helper-friendly markers—buttons carry `data-pathce-action` (`save-config`, `run`, `add-treatment`, `remove-treatment`), while treatment rows use `data-pathce-field` inputs so `path_ce.js` can hydrate and harvest values without jQuery. Keep status, summary, hint, stacktrace, and job nodes inside `#path_ce_form` for `controlBase`.
- Events: `PathCE.getInstance().events = WCEvents.useEventMap(['pathce:config:loaded', 'pathce:config:saved', 'pathce:config:error', 'pathce:treatment:added', 'pathce:treatment:removed', 'pathce:treatment:updated', 'pathce:status:update', 'pathce:results:update', 'pathce:run:started', 'pathce:run:completed', 'pathce:run:error', 'job:started', 'job:completed', 'job:error'])`. Emit (and subscribe) via this surface instead of scraping DOM state when dashboards or neighbouring controllers depend on Path CE activity.
- Transport: configuration is loaded via `WCHttp.getJson("api/path_ce/config")` and saved with `WCHttp.postJson("api/path_ce/config", WCForms.serializeForm(form, { format: "json" }))` plus harvested treatment rows. Runs queue through `WCHttp.postJson("tasks/path_cost_effective_run", {})`, and polling flows through `api/path_ce/status` / `api/path_ce/results`. The Flask blueprint now routes all incoming payloads through `parse_request_payload` before assigning to `PathCostEffective.config`, so keep frontend payloads native (floats, arrays, booleans).
- Tests: Jest coverage in `controllers_js/__tests__/path_ce.test.js` exercises config hydration, treatment table interactions, lifecycle events, and error paths; backend coverage lives in `tests/weppcloud/routes/test_path_ce_bp.py` (using `tests.factories.singleton_factory` + `rq_environment`). Run `wctl run-npm test -- path_ce`, rebuild the bundle (`python wepppy/weppcloud/controllers_js/build_controllers_js.py`), and execute `wctl run-pytest tests/weppcloud/routes/test_path_ce_bp.py` whenever Path CE code changes. Update `docs/work-packages/20251023_controller_modernization/notes/archived-plans/path-ce-controller-plan.md` with new payload schemas/events as you iterate.

### DSS Export controller reference
- DOM hooks: radios expose `data-action="dss-export-mode"` + `data-dss-export-mode="<1|2>"`, the command button uses `data-action="dss-export-run"`, and the mode stacks stay under `#dss_export_mode1_controls` / `#dss_export_mode2_controls` so `WCDom.show/hide` handles toggles. Keep status/stacktrace/info within `#dss_export_form` so `controlBase.attach_status_stream` can manage telemetry.
- Events: `DssExport.getInstance().events = WCEvents.useEventMap(['dss:mode:changed', 'dss:export:started', 'dss:export:completed', 'dss:export:error', 'job:started', 'job:completed', 'job:error'])`. Emit the `dss:*` events for domain listeners (dashboards, run completion prompts) while the inherited `job:*` events keep telemetry pipelines in sync.
- Transport: queue submissions call `WCHttp.postJson("rq/api/post_dss_export_rq", { dss_export_mode, dss_export_channel_ids, dss_export_exclude_orders })`. The Flask route now leans entirely on `parse_request_payload`, normalizes JSON or legacy form posts to native ints/booleans, derives channel IDs from `Watershed.chns_summary` for mode 2, and persists via `wepp.dss_export_mode`, `wepp.dss_excluded_channel_orders`, and `wepp.dss_export_channel_ids`.
- Tests: front-end assertions in `controllers_js/__tests__/dss_export.test.js`; backend coverage in `tests/weppcloud/routes/test_rq_api_dss_export.py` using `tests/factories.singleton_factory` + `tests/factories.rq`. Execute `wctl run-npm lint`, `wctl run-npm test -- dss_export`, rebuild the bundle, and run the targeted pytest plus `wctl run-pytest tests --maxfail=1` (requires `node` for StatusStream) before handoff. Sync the domain note `docs/work-packages/20251023_controller_modernization/notes/archived-plans/dss-export-controller-plan.md` with new payloads/events.

### Batch Runner controller reference
- DOM hooks: templates expose `data-action="batch-upload"`, `data-action="batch-validate"`, and `data-action="batch-run"` for the primary buttons plus `data-run-directive="<slug>"` on task checkboxes. Resource and validation panels rely on the existing `data-role="resource-*"` / `data-role="validation-*"` markers, while status/stacktrace/job info panels stay under `#batch_runner_form` so `controlBase` can drive telemetry. Keep new UI affordances under a `data-batch-*` namespace and wire them through `WCDom.delegate`.
- Events: `BatchRunner.getInstance().emitter = WCEvents.useEventMap([...])` surfaces `batch:upload:started|completed|failed`, `batch:template:validate-started|completed|failed`, `batch:run-directives:updated|update-failed`, `batch:run:started|failed|completed`, plus the inherited `controlBase` lifecycle events (`job:started`, `job:completed`, `job:error`). Subscribe to these events rather than reading internal state or private fields.
- Transport: uploads stream `FormData` to `/batch/_/<name>/upload-geojson`; template validation and directive updates post JSON to `/validate-template` and `/run-directives`; run submissions post JSON to `/rq/api/run-batch`. The Flask routes now call `parse_request_payload`, and `BatchRunner.update_run_directives` converts `"true"/"false"` style strings to native booleans before persisting state.
- Tests: front-end coverage in `controllers_js/__tests__/batch_runner.test.js`; backend coverage in `tests/weppcloud/test_batch_runner_endpoints.py` (upload/validation/directives) and `tests/weppcloud/routes/test_rq_api_batch_runner.py` (queue wiring). Run `wctl run-npm test -- batch_runner`, rebuild the bundle, and execute the targeted pytest suites when touching this controller. Keep `docs/work-packages/20251023_controller_modernization/notes/archived-plans/batch-runner-controller-plan.md` updated with payload schemas, event contracts, and open questions.


## Testing & Tooling Notes
- Jest config lives in `static-src/jest.config.mjs` (jsdom + ESM). Execute via `wctl run-npm test`; the script sets `NODE_OPTIONS=--experimental-vm-modules` automatically.
- ESLint config lives in `.eslintrc.cjs`. Run `wctl run-npm lint` (add `-- --fix` for auto-fixes) and prefer `wctl run-npm check` before handoff.
- Add new suites under `controllers_js/__tests__/` and keep them self-contained (each suite should import the helper(s) it exercises).
- If the bundle grows new helpers, document both usage and ordering in `README.md` and extend test coverage to guard the public API.
- `__tests__/landuse.test.js`, `__tests__/soil.test.js`, and `__tests__/wepp.test.js` exercise helper-based controllers; mirror their setup when migrating additional controls away from jQuery (stub helpers, bootstrap DOM, assert on helper calls, and verify lifecycle events).

## Communication
- If a change affects other repos (e.g., static assets build), annotate the summary so downstream maintainers can align.
- When you discover missing specs or conflicting docs, update this playbook and `README.md` together to keep humans and agents synchronized.
- Capture new primitives or helper upgrades in `docs/dev-notes/controller_foundations.md` so future agents inherit the context automatically.
