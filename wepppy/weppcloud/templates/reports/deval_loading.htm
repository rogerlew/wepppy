{% extends "base_pure.htm" %}

{% block title %}Generating DEVAL Details{% endblock %}

{% block body %}
<section class="wc-panel wc-stack" aria-live="polite">
  <header class="wc-stack">
    <h1>Preparing “Deval in the Details”</h1>
    <div id="statusChip" class="wc-status-chip" data-state="{{ job_status or 'queued' }}">{{ (job_status or 'queued')|upper }}</div>
  </header>

  <div class="wc-meta-list">
    <div>Run ID: <code>{{ runid }}</code></div>
    {% if config %}
    <div>Configuration: <code>{{ config }}</code></div>
    {% endif %}
    {% if job_id %}
    <div>Job ID: <code>{{ job_id }}</code>{% if job_dashboard_url %} · <a href="{{ job_dashboard_url }}" target="_blank" rel="noopener">Inspect job status</a>{% endif %}</div>
    {% endif %}
    <div>This page refreshes automatically once the render finishes.</div>
  </div>

  {% if skip_cache %}
  <div class="wc-status" data-state="attention">
    <strong>Fresh render requested.</strong> The cached HTML will be replaced when the job completes.
  </div>
  {% endif %}

  <div id="statusNote" class="wc-status-note" data-state="active">
    <span id="statusSpinner" class="wc-spinner" aria-hidden="true"></span>
    <span id="statusText">Waiting for the renderer to acknowledge the job…</span>
  </div>

  <div id="errorPanel" class="wc-status-note" data-state="error" hidden>
    <div class="wc-stack">
      <strong>Rendering failed.</strong>
      <div id="errorMessage"></div>
      <p>
        Retry from the run summary by selecting “Deval in the Details” again,
        or force a rebuild with the <code>?no-cache=1</code> query parameter.
      </p>
    </div>
  </div>

  <noscript>
    <div class="wc-status" data-state="attention">
      JavaScript is required to monitor the job status automatically. Enable JavaScript and reload,
      or refresh this page manually to check whether the report is ready.
    </div>
  </noscript>
</section>
{% endblock %}

{% block script_extras %}
<script>
  const jobId = {{ job_id|tojson }};
  const initialStatus = {{ job_status|tojson }};
  const jobStatusUrl = {{ job_status_url|tojson }};
  const refreshUrl = {{ refresh_url|tojson }};
  const ACTIVE_STATES = new Set(["queued", "started", "deferred", "scheduled"]);
  const FAILURE_STATES = new Set(["failed", "stopped", "canceled"]);
  const statusChip = document.getElementById("statusChip");
  const errorPanel = document.getElementById("errorPanel");
  const errorMessage = document.getElementById("errorMessage");
  const statusText = document.getElementById("statusText");
  const statusSpinner = document.getElementById("statusSpinner");
  const statusNote = document.getElementById("statusNote");
  const POLL_INTERVAL_MS = 800;
  const MAX_POLL_ERRORS = 5;
  const SPINNER_FRAMES = ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"];
  let pollTimer = null;
  let spinnerTimer = null;
  let spinnerIndex = 0;
  let lastState = initialStatus || "queued";
  let consecutiveErrors = 0;

  function updateSpinner(active) {
    if (!statusSpinner) {
      return;
    }
    if (!active) {
      statusSpinner.style.visibility = "hidden";
      statusSpinner.textContent = "";
      if (spinnerTimer) {
        window.clearInterval(spinnerTimer);
        spinnerTimer = null;
      }
      return;
    }
    statusSpinner.style.visibility = "visible";
    if (!spinnerTimer) {
      spinnerTimer = window.setInterval(() => {
        statusSpinner.textContent = SPINNER_FRAMES[spinnerIndex % SPINNER_FRAMES.length];
        spinnerIndex += 1;
      }, 120);
    }
  }

  function applyState(state, note) {
    statusChip.dataset.state = state;
    statusChip.textContent = (state || '').toUpperCase();
    statusNote.dataset.state = note;
  }

  function handleActive(state) {
    updateSpinner(true);
    applyState(state, "active");
    statusText.textContent = state === "queued"
      ? "Job queued. Waiting for a worker…"
      : "Rendering in progress…";
  }

  function handleSuccess() {
    updateSpinner(false);
    applyState("finished", "active");
    statusText.textContent = "Render finished. Redirecting…";
    window.setTimeout(() => window.location.replace(refreshUrl), 400);
  }

  function handleFailure(state, message) {
    updateSpinner(false);
    applyState(state, "error");
    statusText.textContent = "Render failed.";
    if (errorPanel) {
      errorPanel.hidden = false;
      if (errorMessage) {
        errorMessage.textContent = message || "No additional details were provided.";
      }
    }
  }

  async function pollStatus() {
    if (!jobId || !jobStatusUrl) {
      return handleFailure("unknown", "Job could not be enqueued.");
    }
    try {
      const response = await fetch(jobStatusUrl, { headers: { 'Accept': 'application/json' } });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      // Check if response is actually JSON
      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error(`Expected JSON response, got ${contentType || 'unknown content type'}`);
      }
      
      const payload = await response.json();
      const state = payload.status || payload.job_status || 'unknown';
      consecutiveErrors = 0; // Reset error counter on successful poll
      if (state === lastState) {
        return;
      }
      lastState = state;
      if (ACTIVE_STATES.has(state)) {
        handleActive(state);
        return;
      }
      if (FAILURE_STATES.has(state)) {
        handleFailure(state, payload.description || payload.error || '' );
        if (pollTimer) {
          window.clearInterval(pollTimer);
        }
        return;
      }
      handleSuccess();
      if (pollTimer) {
        window.clearInterval(pollTimer);
      }
    } catch (error) {
      console.error('Failed to poll job status', error);
      consecutiveErrors += 1;
      
      // Only fail permanently after multiple consecutive errors
      if (consecutiveErrors >= MAX_POLL_ERRORS) {
        handleFailure('failed', `Unable to reach the job status endpoint after ${MAX_POLL_ERRORS} attempts. ${error.message || ''}`);
        if (pollTimer) {
          window.clearInterval(pollTimer);
        }
      } else {
        // Show a transient error but keep polling
        if (statusText) {
          statusText.textContent = `Connection issue (attempt ${consecutiveErrors}/${MAX_POLL_ERRORS}). Retrying…`;
        }
      }
    }
  }

  if (!jobId) {
    handleFailure('failed', 'No job identifier was provided.');
  } else if (!initialStatus || ACTIVE_STATES.has(initialStatus)) {
    handleActive(initialStatus || 'queued');
    pollTimer = window.setInterval(pollStatus, POLL_INTERVAL_MS);
  } else if (FAILURE_STATES.has(initialStatus)) {
    handleFailure(initialStatus, 'Renderer reported a failure before polling began.');
  } else {
    handleSuccess();
  }
</script>
{% endblock %}
