{% extends "reports/_base_report.htm" %}
{% block report_title %}Observed Comparison{% endblock %}

{% block head_extras %}
<script>
  window.__nativeMap = window.__nativeMap || window.Map;
</script>
<script src="{{ url_for('static', filename='js/d3.js') }}" defer></script>
{{ super() }}
<style>
  .wc-observed {
    font: 16px sans-serif;
  }

  .wc-observed .axis path,
  .wc-observed .axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
  }

  .wc-observed .brush .selection {
    stroke: #fff;
    fill-opacity: 0.15;
    shape-rendering: crispEdges;
  }

  .wc-observed .brush .handle {
    fill: var(--handle-fill, #999);
    stroke: var(--handle-stroke, #515050);
    stroke-width: var(--handle-stroke-width, 1);
    opacity: var(--handle-opacity, 0.8);
    rx: 2px;
    ry: 2px;
  }

  .wc-observed .brush .handle--w,
  .wc-observed .brush .handle--e {
    cursor: ew-resize;
    width: var(--handle-size, 4px);
  }

  .wc-observed .x.axis path {
    display: none;
  }

  .wc-observed .line {
    fill: none;
    stroke-width: 1.8px;
  }

  .wc-observed .legend-horizontal {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 12px;
    margin-bottom: 6px;
    font: 12px sans-serif;
  }

  .wc-observed .legend-item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    user-select: none;
  }

  .wc-observed .legend-swatch {
    width: 16px;
    height: 12px;
    border: 1px solid #444;
    border-radius: 2px;
  }

  .wc-observed svg {
    display: block;
    width: 100%;
    max-width: 100%;
    height: auto;
  }

  .wc-observed svg,
  .wc-observed .focus,
  .wc-observed .context {
    user-select: none;
  }

  .wc-observed .axis text {
    font-size: 13px;
    font-weight: 500;
  }

  .wc-observed .axis-label {
    font-size: 14px;
    font-weight: 500;
  }
</style>
{% endblock %}

{% block report_content %}
<header class="wc-stack">
  <h1 class="wc-heading__title">Observed vs Simulated</h1>
  <p class="wc-text-muted">
    {{ selected_label or "Observed data" }}{% if selected_period %} ({{ selected_period }}){% endif %}{% if selected_scope %} for {{ selected_scope }}{% endif %}.
  </p>
</header>

<section class="wc-panel wc-stack">
  <header class="wc-stack">
    <h2 class="wc-heading__subtitle">Configuration</h2>
  </header>
  {% if graph_series %}
    <div class="wc-inline">
      <label>
        <span class="wc-text-muted">Observed series</span>
        <select id="observedSeriesSelection">
          {% for option in graph_series %}
            <option value="{{ url_for_run('observed.plot_observed', runid=runid, config=config, selected=option) }}"{% if selected == option %} selected{% endif %}>{{ option }}</option>
          {% endfor %}
        </select>
      </label>
    </div>
  {% else %}
    <p class="wc-text-muted">No observed comparison files found for this run.</p>
  {% endif %}
</section>

<section class="wc-panel wc-stack">
  <div class="wc-observed">
    <div id="legend" class="legend-horizontal"></div>
    <div id="observed-chart"></div>
  </div>
  <script id="observed-chart-config" type="application/json">{{ {
    "dataUrl": data_url,
    "dateFormat": parseDate_fmt,
    "measureLabel": selected_label,
    "periodLabel": selected_period,
    "scopeLabel": selected_scope
  } | tojson | safe }}</script>
</section>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const selection = document.getElementById('observedSeriesSelection');
    if (selection) {
      selection.addEventListener('change', function () {
        if (this.value) {
          window.location.href = this.value;
        }
      });
    }

    if (typeof d3 === 'undefined') {
      console.error('d3.js failed to load; observed comparison plot unavailable.');
      return;
    }

    const configElement = document.getElementById('observed-chart-config');
    let chartConfig = {};
    if (configElement) {
      try {
        chartConfig = JSON.parse(configElement.textContent || '{}');
      } catch (err) {
        console.warn('Failed to parse observed chart config', err);
      }
    }

    const dataUrl = chartConfig.dataUrl || null;
    const dateFormat = chartConfig.dateFormat || null;
    const measureLabel = chartConfig.measureLabel || 'Value';

    const SERIES = [
      { key: 'Modeled', label: 'Simulated', color: '#1e90ff' },
      { key: 'Observed', label: 'Observed', color: '#ff8c2a' }
    ];

    const container = document.getElementById('observed-chart');
    const chartWrapper = container ? container.closest('.wc-observed') : null;
    const legendContainer = document.getElementById('legend');
    const widthMeasureHost = chartWrapper ? chartWrapper.closest('.wc-panel') : null;

    const parseDate = dateFormat ? d3.utcParse(dateFormat) : null;
    const nativeMap = window.__nativeMap || window.Map;
    window.Map = nativeMap;

    let rows = [];
    let lastRenderedHostWidth = null;
    let lastRenderedAvailableWidth = null;
    let pendingFrame = null;

    function parseNumber(value) {
      const num = parseFloat(value);
      return Number.isFinite(num) ? num : null;
    }

    function parseRows(data) {
      return data.map(row => {
        const rawDate = row.date || row.Date;
        const parsed = parseDate ? parseDate(rawDate) : null;
        const date = parsed || new Date(rawDate);
        if (!date || Number.isNaN(date.getTime())) {
          return null;
        }
        return {
          date: date,
          Modeled: parseNumber(row.Modeled),
          Observed: parseNumber(row.Observed)
        };
      }).filter(Boolean);
    }

    function getHostWidth() {
      if (widthMeasureHost) {
        const rect = widthMeasureHost.getBoundingClientRect();
        return rect && rect.width ? rect.width : widthMeasureHost.clientWidth || 0;
      }
      if (chartWrapper) {
        const rect = chartWrapper.getBoundingClientRect();
        return rect && rect.width ? rect.width : chartWrapper.clientWidth || 0;
      }
      if (container) {
        const rect = container.getBoundingClientRect();
        return rect && rect.width ? rect.width : container.clientWidth || 0;
      }
      return window.innerWidth || 0;
    }

    function getAvailableWidth() {
      const hostWidth = getHostWidth();
      const viewportWidth = document.documentElement ? document.documentElement.clientWidth : window.innerWidth;
      const safeViewport = Math.max(0, viewportWidth || window.innerWidth || 0);
      const viewportLimit = safeViewport ? Math.max(320, safeViewport - 32) : null;

      let candidate = hostWidth || (window.innerWidth ? window.innerWidth * 0.95 : 0);

      if (widthMeasureHost && hostWidth) {
        const computed = window.getComputedStyle(widthMeasureHost);
        const paddingLeft = parseFloat(computed.paddingLeft || '0');
        const paddingRight = parseFloat(computed.paddingRight || '0');
        candidate = Math.max(320, hostWidth - paddingLeft - paddingRight);
      } else if (hostWidth) {
        candidate = Math.max(320, hostWidth);
      } else {
        candidate = Math.max(320, candidate);
      }

      if (viewportLimit) {
        candidate = Math.min(candidate, viewportLimit);
      }

      return candidate;
    }

    function scheduleBuild() {
      if (pendingFrame !== null) {
        cancelAnimationFrame(pendingFrame);
      }
      pendingFrame = requestAnimationFrame(() => {
        pendingFrame = null;
        const hostWidth = getHostWidth();
        const availableWidth = getAvailableWidth();
        const hostUnchanged = lastRenderedHostWidth !== null && Math.abs(hostWidth - lastRenderedHostWidth) <= 1;
        const availableUnchanged = lastRenderedAvailableWidth !== null && Math.abs(availableWidth - lastRenderedAvailableWidth) <= 1;
        if (hostUnchanged && availableUnchanged) {
          return;
        }
        buildChart();
      });
    }

    function buildLegend(series) {
      if (!legendContainer) {
        return;
      }
      const cont = d3.select(legendContainer);
      cont.selectAll('*').remove();

      const items = cont.selectAll('div.legend-item')
        .data(series)
        .enter()
        .append('div')
        .attr('class', 'legend-item');

      items.append('span')
        .attr('class', 'legend-swatch')
        .style('background', d => d.color);

      items.append('span')
        .text(d => d.label);
    }

    function buildChart() {
      if (!container) {
        return;
      }

      const areaRoot = d3.select(container);
      areaRoot.selectAll('*').remove();
      if (legendContainer) {
        d3.select(legendContainer).selectAll('*').remove();
      }

      if (!rows.length) {
        areaRoot.append('p')
          .attr('class', 'wc-text-muted')
          .text('Observed comparison data unavailable for the selected series.');
        return;
      }

      const availableWidth = getAvailableWidth();
      const rightMargin = 60;
      const margin = { top: 10, right: rightMargin, bottom: (window.innerHeight - 80) * 0.2, left: 60 };
      const margin2 = { top: (window.innerHeight - 80) * 0.8, right: rightMargin, bottom: 70, left: 60 };

      const width = Math.max(160, availableWidth - margin.left - margin.right);
      const rawHeight = window.innerHeight * 0.95 - 80 - margin.top - margin.bottom;
      const rawHeight2 = window.innerHeight * 0.95 - 80 - margin2.top - margin2.bottom;
      const height = Math.max(220, rawHeight);
      const height2 = Math.max(80, rawHeight2);

      lastRenderedHostWidth = getHostWidth();
      lastRenderedAvailableWidth = availableWidth;

      const totalWidth = width + margin.left + margin.right;
      const totalHeight = height + margin.top + margin.bottom;

      const x = d3.scaleTime().range([0, width]);
      const xC = d3.scaleTime().range([0, width]);
      const y = d3.scaleLinear().range([height, 0]);
      const yC = d3.scaleLinear().range([height2, 0]);

      const series = SERIES.map(def => ({
        key: def.key,
        label: def.label,
        color: def.color,
        values: rows.map(row => ({ date: row.date, value: row[def.key] }))
      }));

      const values = series.flatMap(s => s.values.map(point => point.value).filter(val => val !== null));
      const yMin = Math.min(0, d3.min(values) ?? 0);
      const yMax = d3.max(values) ?? 1;

      x.domain(d3.extent(rows, row => row.date));
      xC.domain(x.domain());
      y.domain([yMin, yMax]);
      yC.domain(y.domain());

      const xAxis = d3.axisBottom(x);
      const xAxisC = d3.axisBottom(xC);
      const yAxis = d3.axisLeft(y);
      const yAxisC = d3.axisLeft(yC).ticks(2);

      const line = d3.line()
        .defined(d => d.value !== null && !Number.isNaN(d.value))
        .x(d => x(d.date))
        .y(d => y(d.value));

      const lineC = d3.line()
        .defined(d => d.value !== null && !Number.isNaN(d.value))
        .x(d => xC(d.date))
        .y(d => yC(d.value));

      const svg = areaRoot.append('svg')
        .attr('viewBox', `0 0 ${totalWidth} ${totalHeight}`)
        .attr('width', totalWidth)
        .attr('height', totalHeight)
        .style('width', '100%')
        .style('height', 'auto')
        .style('display', 'block');

      const clipId = `clip-${Math.random().toString(36).slice(2, 10)}`;
      const contextClipId = `clip-context-${Math.random().toString(36).slice(2, 10)}`;

      svg.append('defs').append('clipPath')
        .attr('id', clipId)
        .append('rect')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', width)
        .attr('height', height);

      svg.append('defs').append('clipPath')
        .attr('id', contextClipId)
        .append('rect')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', width)
        .attr('height', height2);

      const focus = svg.append('g')
        .attr('class', 'focus')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      const context = svg.append('g')
        .attr('class', 'context')
        .attr('transform', `translate(${margin2.left},${margin2.top})`);

      const linesGroup = focus.append('g')
        .attr('class', 'lines')
        .attr('clip-path', `url(#${clipId})`);

      linesGroup.selectAll('path')
        .data(series)
        .enter()
        .append('path')
        .attr('class', 'line')
        .attr('stroke', d => d.color)
        .attr('d', d => line(d.values));

      focus.append('g')
        .attr('class', 'x axis')
        .attr('transform', `translate(0,${height})`)
        .call(xAxis);

      const yAxisGroup = focus.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

      yAxisGroup.append('text')
        .attr('fill', '#000')
        .attr('transform', 'rotate(-90)')
        .attr('x', -height / 2)
        .attr('y', -45)
        .attr('text-anchor', 'middle')
        .attr('class', 'axis-label')
        .text(measureLabel || 'Value');

      const contextLinesGroup = context.append('g')
        .attr('class', 'lines')
        .attr('clip-path', `url(#${contextClipId})`);

      contextLinesGroup.selectAll('path')
        .data(series)
        .enter()
        .append('path')
        .attr('class', 'line')
        .attr('stroke', d => d.color)
        .attr('d', d => lineC(d.values));

      context.append('g')
        .attr('class', 'x axis')
        .attr('transform', `translate(0,${height2})`)
        .call(xAxisC);

      context.append('g')
        .attr('class', 'y axis')
        .call(yAxisC);

      const brush = d3.brushX()
        .extent([[0, 0], [width, height2]])
        .on('brush end', brushed);

      context.append('g')
        .attr('class', 'x brush')
        .call(brush)
        .call(brush.move, x.range())
        .selectAll('.handle').attr('display', null);

      function brushed(event) {
        const selection = event.selection;
        x.domain(selection ? selection.map(xC.invert) : xC.domain());
        focus.select('.x.axis').call(xAxis);
        linesGroup.selectAll('path').attr('d', d => line(d.values));
      }

      context.append('text')
        .attr('class', 'axis-label')
        .attr('transform', `translate(${width / 2},${height2 + margin2.bottom - 12})`)
        .style('text-anchor', 'middle')
        .text('Date');

      buildLegend(series);
    }

    function loadData() {
      if (!container) {
        return;
      }
      if (!dataUrl) {
        d3.select(container)
          .append('p')
          .attr('class', 'wc-text-muted')
          .text('Observed comparison data unavailable for the selected series.');
        return;
      }

      d3.csv(dataUrl)
        .then(data => {
          rows = parseRows(data);
          buildChart();
        })
        .catch(err => {
          console.warn('Failed to load observed comparison data', err);
          d3.select(container)
            .append('p')
            .attr('class', 'wc-text-muted')
            .text('Failed to load observed comparison data.');
        });
    }

    loadData();

    window.addEventListener('resize', scheduleBuild);
    window.addEventListener('orientationchange', scheduleBuild);

    if (window.ResizeObserver && (widthMeasureHost || chartWrapper)) {
      const resizeObserver = new ResizeObserver((entries) => {
        if (!entries || !entries.length) {
          return;
        }
        const entry = entries[0];
        if (!entry.contentRect) {
          scheduleBuild();
          return;
        }
        const availableWidth = getAvailableWidth();
        if (
          lastRenderedHostWidth === null ||
          Math.abs(entry.contentRect.width - lastRenderedHostWidth) > 1 ||
          lastRenderedAvailableWidth === null ||
          Math.abs(availableWidth - lastRenderedAvailableWidth) > 1
        ) {
          scheduleBuild();
        }
      });
      resizeObserver.observe(widthMeasureHost || chartWrapper);
    }
  });
</script>
{% endblock %}
