{% extends "base_pure.htm" %}

{% block title %}Runs{% endblock %}

{% block body_container_class %}wc-container wc-container--fluid{% endblock %}
{% block header_container_class %}wc-container wc-container--fluid{% endblock %}

{% block body %}
{% macro sortable_header(label, field) -%}
  {% set current_sort = sort | default('last_modified', true) %}
  {% set current_direction = direction | default('desc', true) %}
  {% set sort_endpoint = runs_sort_endpoint | default('user.runs', true) %}
  {% set is_active = (current_sort == field) %}
  {% set asc_active = is_active and current_direction == 'asc' %}
  {% set desc_active = is_active and current_direction == 'desc' %}
  {% set per_page_value = per_page | default(25, true) %}
  {% if asc_active %}
    {% set indicator = '▲' %}
    {% set aria_sort = 'ascending' %}
  {% elif desc_active %}
    {% set indicator = '▼' %}
    {% set aria_sort = 'descending' %}
  {% else %}
    {% set indicator = '↕' %}
    {% set aria_sort = 'none' %}
  {% endif %}
  {% if is_active %}
    {% if current_direction == 'asc' %}
      {% set next_direction = 'desc' %}
    {% else %}
      {% set next_direction = 'asc' %}
    {% endif %}
  {% else %}
    {% set next_direction = 'asc' %}
  {% endif %}
  {% set next_direction_label = 'descending' if next_direction == 'desc' else 'ascending' %}
  <th scope="col"
      class="sortable-header"
      data-sort-direction="{{ current_direction if is_active else 'none' }}"
      aria-sort="{{ aria_sort }}">
    <a class="wc-server-sort"
       href="{{ url_for(sort_endpoint, page=1, sort=field, direction=next_direction, per_page=per_page_value) }}"
       aria-label="Sort {{ label }} {{ next_direction_label }}"
       data-next-direction="{{ next_direction }}">
      <span class="wc-server-sort__label">{{ label }}</span>
      <span class="sortable-indicator" aria-hidden="true">{{ indicator }}</span>
    </a>
  </th>
{%- endmacro %}
{% set column_count = 8 + (1 if show_owner else 0) %}
<section class="wc-stack wc-table-page">
  <header class="wc-stack">
    <div class="wc-console-header">
      <div class="wc-console-header__primary">
        <div class="wc-stack">
          <h1 class="wc-heading__title">Runs</h1>
          <div class="wc-tabs__nav" role="tablist" aria-label="Runs view">
            <button class="wc-tabs__tab is-active" id="runs-tab-table" type="button" role="tab" aria-selected="true" aria-controls="runs-table-view">
              Table
            </button>
            <button class="wc-tabs__tab" id="runs-tab-map" type="button" role="tab" aria-selected="false" aria-controls="runs-map-view">
              Map
            </button>
          </div>
        </div>
      </div>
    </div>
  </header>

  <section class="wc-panel wc-stack">
    <div id="runs-table-view" role="tabpanel" aria-labelledby="runs-tab-table">
      <div class="wc-map-controls">
        <div class="wc-map-controls__row wc-map-controls__row--inputs">
          <label class="wc-map-controls__label" for="runs_search_input">Search runs</label>
          <div class="wc-map-controls__input">
            <input class="wc-map-controls__input-field wc-field__control wc-field__control--text"
                   id="runs_search_input"
                   name="runs_search_input"
                   type="text"
                   placeholder="Name | Scenario | Run ID"
                   autocomplete="off"
                   inputmode="text">
          </div>
          <div class="wc-map-controls__actions">
            <button type="button" class="pure-button pure-button-secondary" id="runs_search_clear" disabled>Clear</button>
          </div>
          <div class="wc-map-controls__go">
            <button type="button" class="pure-button pure-button-primary" id="runs_search_go">Search</button>
          </div>
        </div>
      </div>
      <div class="wc-toolbar wc-toolbar--end">
        <button type="button" class="pure-button pure-button-secondary" id="delete_runs_button" onclick="deleteRuns()" disabled>Delete selected</button>
      </div>

      <div class="wc-table-wrapper">
        <table class="wc-table wc-table--dense" id="runs_table">
          <thead>
            <tr>
              {% if show_owner %}<th scope="col">Owner</th>{% endif %}
              {{ sortable_header('Project name', 'name') }}
              {{ sortable_header('Scenario', 'scenario') }}
              {{ sortable_header('Run ID', 'runid') }}
              {{ sortable_header('Config', 'config') }}
              <th scope="col">Link</th>
              {{ sortable_header('Creation date', 'date_created') }}
              {{ sortable_header('Last modified', 'last_modified') }}
              <th scope="col" class="wc-text-muted" title="Do not add columns that normalize casing in headers.">Select</th>
            </tr>
          </thead>
          <tbody id="runs_table_body">
            <tr id="runs_empty_row" data-empty-row="true">
              <td colspan="{{ column_count }}" class="wc-text-muted">Loading runs...</td>
            </tr>
          </tbody>
        </table>
      </div>
      <nav id="runs-pagination" aria-label="Runs pagination" class="wc-pagination wc-pagination-nav" hidden></nav>
    </div>

    <div id="runs-map-view" role="tabpanel" aria-labelledby="runs-tab-map" hidden>
      <div class="wc-map" style="aspect-ratio: 16 / 9; min-height: 420px;">
        <div id="runs-map-canvas" class="wc-map__canvas" role="application" aria-label="Runs map viewport"></div>
      </div>
      <div id="runs-map-status" class="wc-text-muted" aria-live="polite" style="margin-top: var(--wc-space-sm);">
        Switch to Map to load run locations.
      </div>
    </div>
  </section>
</section>

<script>
  const sitePrefix = {{ site_prefix | default('', true) | tojson }};
  const deleteButton = document.getElementById('delete_runs_button');
  const runsTable = document.getElementById('runs_table');
  const runsTableBody = document.getElementById('runs_table_body');
  const runsEmptyRow = document.getElementById('runs_empty_row');
  const runsPagination = document.getElementById('runs-pagination');
  const runsTableView = document.getElementById('runs-table-view');
  const runsMapView = document.getElementById('runs-map-view');
  const runsTabTable = document.getElementById('runs-tab-table');
  const runsTabMap = document.getElementById('runs-tab-map');
  const runsMapStatus = document.getElementById('runs-map-status');
  const runsMapCanvas = document.getElementById('runs-map-canvas');
  const runsSearchInput = document.getElementById('runs_search_input');
  const runsSearchClear = document.getElementById('runs_search_clear');
  const runsSearchGo = document.getElementById('runs_search_go');
  const showOwner = {{ show_owner | tojson }};
  const runsSortParam = {{ sort | default('last_modified', true) | tojson }};
  const runsDirectionParam = {{ direction | default('desc', true) | tojson }};
  const runsPerPageDefault = {{ per_page | default(25, true) | tojson }};
  {% if show_owner %}
  const runsCatalogUrl = {{ url_for('user.runs_catalog', scope='all') | tojson }};
  const runsMapDataUrl = {{ url_for('user.runs_map_data', scope='all') | tojson }};
  {% else %}
  const runsCatalogUrl = {{ url_for('user.runs_catalog') | tojson }};
  const runsMapDataUrl = {{ url_for('user.runs_map_data') | tojson }};
  {% endif %}
  let runsCatalog = [];
  let runsFiltered = [];
  let runsCatalogLoaded = false;
  let currentPage = 1;
  let perPage = runsPerPageDefault;
  let searchQuery = '';
  let runsMapInitialized = false;
  let runsMapDeck = null;

  const initialParams = new URLSearchParams(window.location.search);
  const pageParam = parseInt(initialParams.get('page'), 10);
  if (Number.isFinite(pageParam) && pageParam > 0) {
    currentPage = pageParam;
  }
  const perPageParam = parseInt(initialParams.get('per_page'), 10);
  if (Number.isFinite(perPageParam) && perPageParam > 0) {
    perPage = perPageParam;
  }
  const queryParam = (initialParams.get('q') || '').trim();
  if (queryParam) {
    searchQuery = queryParam;
    if (runsSearchInput) {
      runsSearchInput.value = searchQuery;
    }
  }

  function buildRunsCatalogUrl() {
    const params = new URLSearchParams();
    if (runsSortParam) {
      params.set('sort', runsSortParam);
    }
    if (runsDirectionParam) {
      params.set('direction', runsDirectionParam);
    }
    const query = params.toString();
    return query ? `${runsCatalogUrl}?${query}` : runsCatalogUrl;
  }

  function updateRunsUrl() {
    const params = new URLSearchParams();
    params.set('page', String(currentPage));
    params.set('per_page', String(perPage));
    if (runsSortParam) {
      params.set('sort', runsSortParam);
    }
    if (runsDirectionParam) {
      params.set('direction', runsDirectionParam);
    }
    if (searchQuery) {
      params.set('q', searchQuery);
    }
    const query = params.toString();
    const nextUrl = query ? `${window.location.pathname}?${query}` : window.location.pathname;
    window.history.replaceState(null, '', nextUrl);
  }

  function buildSearchIndex(run) {
    return [run.name, run.scenario, run.runid].filter(Boolean).join(' ').toLowerCase();
  }

  function setRunsEmptyMessage(message) {
    if (!runsEmptyRow) {
      return;
    }
    const cell = runsEmptyRow.querySelector('td');
    if (cell) {
      cell.textContent = message;
    }
    runsEmptyRow.hidden = false;
  }

  function clearRunRows() {
    if (!runsTableBody) {
      return;
    }
    runsTableBody.querySelectorAll('tr[data-run-row="true"]').forEach((row) => row.remove());
  }

  function formatOptionalValue(value) {
    if (value === null || value === undefined || value === '') {
      return '—';
    }
    return String(value);
  }

  function buildRunRow(run) {
    const row = document.createElement('tr');
    row.dataset.runRow = 'true';
    if (run.runid) {
      row.id = run.runid;
    }
    row.dataset.search = run.searchIndex || '';

    function appendCell(text) {
      const cell = document.createElement('td');
      cell.textContent = text;
      row.appendChild(cell);
    }

    if (showOwner) {
      appendCell(formatOptionalValue(run.owner || ''));
    }
    appendCell(formatOptionalValue(run.name || ''));
    appendCell(formatOptionalValue(run.scenario || ''));
    appendCell(formatOptionalValue(run.runid || ''));
    appendCell(formatOptionalValue(run.config || ''));

    const linkCell = document.createElement('td');
    const link = document.createElement('a');
    link.className = 'pure-button pure-button-secondary';
    link.href = `${sitePrefix}/runs/${run.runid}/${run.config}/`;
    link.target = '_blank';
    link.rel = 'noopener';
    link.textContent = 'Open';
    linkCell.appendChild(link);
    row.appendChild(linkCell);

    appendCell(formatOptionalValue(run.date_created));
    appendCell(formatOptionalValue(run.last_modified));

    const selectCell = document.createElement('td');
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = run.runid || '';
    checkbox.disabled = !!run.readonly;
    checkbox.setAttribute('aria-label', `Select ${run.runid || ''}`);
    checkbox.addEventListener('change', updateDeleteState);
    selectCell.appendChild(checkbox);
    row.appendChild(selectCell);

    return row;
  }

  function getTotalPages() {
    if (!perPage || perPage <= 0) {
      return 1;
    }
    return Math.ceil(runsFiltered.length / perPage) || 1;
  }

  function renderRunsTable() {
    if (!runsTableBody) {
      return;
    }
    clearRunRows();

    if (!runsCatalogLoaded) {
      setRunsEmptyMessage('Loading runs...');
      return;
    }

    const totalPages = getTotalPages();
    if (currentPage > totalPages) {
      currentPage = totalPages;
    }
    const start = (currentPage - 1) * perPage;
    const end = start + perPage;
    const pageRuns = perPage > 0 ? runsFiltered.slice(start, end) : runsFiltered;

    if (!pageRuns.length) {
      const message = searchQuery ? 'No matching runs found.' : 'No runs found.';
      setRunsEmptyMessage(message);
      return;
    }

    if (runsEmptyRow) {
      runsEmptyRow.hidden = true;
    }

    const fragment = document.createDocumentFragment();
    pageRuns.forEach((run) => {
      fragment.appendChild(buildRunRow(run));
    });
    runsTableBody.insertBefore(fragment, runsEmptyRow);
    updateDeleteState();
  }

  function buildPaginationControl(label, page, ariaLabel) {
    if (!page) {
      const span = document.createElement('span');
      span.className = 'wc-pagination__link';
      span.setAttribute('aria-disabled', 'true');
      span.textContent = label;
      return span;
    }
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'wc-pagination__link';
    button.textContent = label;
    if (ariaLabel) {
      button.setAttribute('aria-label', ariaLabel);
    }
    button.addEventListener('click', () => setRunsPage(page));
    return button;
  }

  function renderPagination() {
    if (!runsPagination) {
      return;
    }
    if (!runsCatalogLoaded) {
      runsPagination.innerHTML = '';
      runsPagination.hidden = true;
      return;
    }
    const totalPages = getTotalPages();
    if (totalPages <= 1) {
      runsPagination.innerHTML = '';
      runsPagination.hidden = true;
      return;
    }
    runsPagination.hidden = false;
    runsPagination.innerHTML = '';
    const fragment = document.createDocumentFragment();

    fragment.appendChild(buildPaginationControl('«', currentPage > 1 ? currentPage - 1 : null, 'Previous page'));

    const start = Math.max(1, currentPage - 2);
    const end = Math.min(totalPages, currentPage + 2);
    for (let page = start; page <= end; page += 1) {
      if (page === currentPage) {
        const span = document.createElement('span');
        span.className = 'wc-pagination__link wc-pagination__link--current';
        span.setAttribute('aria-current', 'page');
        span.textContent = String(page);
        fragment.appendChild(span);
      } else {
        fragment.appendChild(buildPaginationControl(String(page), page));
      }
    }

    fragment.appendChild(buildPaginationControl('»', currentPage < totalPages ? currentPage + 1 : null, 'Next page'));

    runsPagination.appendChild(fragment);
  }

  function setRunsPage(page) {
    currentPage = page;
    renderRunsTable();
    renderPagination();
    updateRunsUrl();
  }

  async function deleteRun(runid) {
    const response = await fetch(`${sitePrefix}/runs/${runid}/0/tasks/delete/`, { method: 'POST' });
    if (response.ok) {
      runsCatalog = runsCatalog.filter((run) => run.runid !== runid);
      applyRunsFilter({ resetPage: false });
    } else {
      console.error('Failed to delete run', runid);
    }
  }

  function updateDeleteState() {
    if (!runsTable || !deleteButton) {
      return;
    }
    const checked = runsTable.querySelectorAll('input[type="checkbox"]:checked');
    deleteButton.disabled = checked.length === 0;
  }

  function applyRunsFilter(options = {}) {
    const query = runsSearchInput ? runsSearchInput.value.trim() : '';
    const normalized = query.toLowerCase();
    const queryChanged = query !== searchQuery;
    if (queryChanged || options.resetPage) {
      currentPage = 1;
    }
    searchQuery = query;
    runsFiltered = normalized
      ? runsCatalog.filter((run) => (run.searchIndex || '').includes(normalized))
      : runsCatalog.slice();
    if (runsSearchClear) {
      runsSearchClear.disabled = query.length === 0;
    }
    renderRunsTable();
    renderPagination();
    updateRunsUrl();
  }

  async function loadRunsCatalog() {
    if (!runsCatalogUrl) {
      return;
    }
    setRunsEmptyMessage('Loading runs...');
    try {
      const response = await fetch(buildRunsCatalogUrl());
      if (!response.ok) {
        throw new Error(`Runs fetch failed ${response.status}`);
      }
      const payload = await response.json();
      runsCatalog = (payload.runs || []).map((run) => ({
        ...run,
        searchIndex: buildSearchIndex(run),
      }));
      runsCatalogLoaded = true;
      applyRunsFilter({ resetPage: false });
    } catch (error) {
      console.error(error);
      runsCatalogLoaded = true;
      setRunsEmptyMessage('Unable to load runs.');
      renderPagination();
    }
  }

  function deleteRuns() {
    if (!runsTable) {
      return;
    }
    const checks = Array.from(runsTable.querySelectorAll('input[type="checkbox"]:checked'));
    if (!checks.length) {
      return;
    }
    const runids = checks.map((el) => el.value);
    const confirmed = window.confirm(`Delete ${runids.join(', ')}?`);
    if (!confirmed) {
      return;
    }
    runids.forEach(deleteRun);
  }

  function setRunsView(view) {
    const isMap = view === 'map';
    if (runsTableView) {
      runsTableView.hidden = isMap;
    }
    if (runsMapView) {
      runsMapView.hidden = !isMap;
    }
    if (runsTabTable) {
      runsTabTable.classList.toggle('is-active', !isMap);
      runsTabTable.setAttribute('aria-selected', (!isMap).toString());
    }
    if (runsTabMap) {
      runsTabMap.classList.toggle('is-active', isMap);
      runsTabMap.setAttribute('aria-selected', isMap.toString());
    }
    if (isMap) {
      initRunsMap();
    }
  }

  function formatRunLabel(run) {
    const runid = run.runid || '';
    const details = [];
    if (run.name) {
      details.push(run.name);
    }
    if (run.scenario) {
      details.push(run.scenario);
    }
    if (!details.length) {
      return runid;
    }
    return `${runid}\n${details.join(' | ')}`;
  }

  function buildViewState(runs) {
    const fallback = {
      longitude: -114.5,
      latitude: 43.8,
      zoom: 4,
      minZoom: 2,
      maxZoom: 17,
      pitch: 0,
      bearing: 0,
    };
    if (!runs.length) {
      return fallback;
    }
    let minLon = null;
    let maxLon = null;
    let minLat = null;
    let maxLat = null;
    runs.forEach((run) => {
      const center = run.map_center;
      if (!center || center.length < 2) {
        return;
      }
      const lon = center[0];
      const lat = center[1];
      if (!Number.isFinite(lon) || !Number.isFinite(lat)) {
        return;
      }
      minLon = minLon === null ? lon : Math.min(minLon, lon);
      maxLon = maxLon === null ? lon : Math.max(maxLon, lon);
      minLat = minLat === null ? lat : Math.min(minLat, lat);
      maxLat = maxLat === null ? lat : Math.max(maxLat, lat);
    });
    if (minLon === null || maxLon === null || minLat === null || maxLat === null) {
      return fallback;
    }
    const span = Math.max(maxLon - minLon, maxLat - minLat);
    const zoom = span ? Math.max(2, Math.min(16, Math.log2(360 / span) + 0.5)) : 12;
    return {
      longitude: (minLon + maxLon) / 2,
      latitude: (minLat + maxLat) / 2,
      zoom,
      minZoom: 2,
      maxZoom: 17,
      pitch: 0,
      bearing: 0,
    };
  }

  function updateMapStatus(message) {
    if (runsMapStatus) {
      runsMapStatus.textContent = message;
    }
  }

  function createTerrainLayer(deckApi) {
    const subdomains = ['mt0', 'mt1', 'mt2', 'mt3'];
    let subdomainIndex = 0;
    const template = 'https://{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}';

    return new deckApi.TileLayer({
      id: 'runs-base-tiles',
      data: template,
      minZoom: 0,
      maxZoom: 19,
      tileSize: 256,
      maxRequests: 8,
      getTileData: async ({ index, signal }) => {
        const { x, y, z } = index || {};
        if (![x, y, z].every(Number.isFinite)) {
          throw new Error(`Tile coords missing: x=${x} y=${y} z=${z}`);
        }
        const sub = subdomains[subdomainIndex % subdomains.length];
        subdomainIndex += 1;
        const url = template
          .replace('{s}', sub)
          .replace('{x}', String(x))
          .replace('{y}', String(y))
          .replace('{z}', String(z));
        const response = await fetch(url, { signal, mode: 'cors' });
        if (!response.ok) {
          throw new Error(`Tile fetch failed ${response.status}: ${url}`);
        }
        const blob = await response.blob();
        return await createImageBitmap(blob);
      },
      onTileError: (err) => {
        console.error('runs map tile error', err);
      },
      renderSubLayers: (props) => {
        const tile = props.tile;
        const data = props.data;
        if (!tile || !data || !tile.bbox) {
          return null;
        }
        const { west, south, east, north } = tile.bbox;
        const bounds = [west, south, east, north];
        if (bounds.some((v) => !Number.isFinite(v))) {
          return null;
        }
        return new deckApi.BitmapLayer(props, {
          id: `${props.id}-${tile.id}`,
          data: null,
          image: data,
          bounds,
          pickable: false,
          opacity: 0.95,
        });
      },
    });
  }

  function waitForDeck() {
    if (window.deck && window.deck.Deck) {
      return Promise.resolve(window.deck);
    }
    return new Promise((resolve, reject) => {
      let attempts = 0;
      const timer = setInterval(() => {
        attempts += 1;
        if (window.deck && window.deck.Deck) {
          clearInterval(timer);
          resolve(window.deck);
          return;
        }
        if (attempts > 20) {
          clearInterval(timer);
          reject(new Error('deck.gl failed to load.'));
        }
      }, 250);
    });
  }

  async function initRunsMap() {
    if (runsMapInitialized) {
      return;
    }
    runsMapInitialized = true;
    if (!runsMapCanvas) {
      updateMapStatus('Runs map container not found.');
      return;
    }
    updateMapStatus('Loading map data...');
    let deckApi;
    try {
      deckApi = await waitForDeck();
    } catch (error) {
      console.error(error);
      updateMapStatus('Map failed to load. deck.gl is unavailable.');
      return;
    }
    let payload;
    try {
      const response = await fetch(runsMapDataUrl);
      if (!response.ok) {
        throw new Error(`Map data fetch failed ${response.status}`);
      }
      payload = await response.json();
    } catch (error) {
      console.error(error);
      updateMapStatus('Unable to load run locations.');
      return;
    }
    const runs = (payload.runs || [])
      .filter((run) => Array.isArray(run.map_center) && run.map_center.length >= 2)
      .map((run) => ({
        ...run,
        label: formatRunLabel(run),
        url: `${sitePrefix}/runs/${run.runid}/${run.config}/`,
      }));

    if (!runs.length) {
      updateMapStatus('No runs with map centers are available yet.');
    } else {
      updateMapStatus(`${runs.length} run${runs.length === 1 ? '' : 's'} mapped.`);
    }

    const viewState = buildViewState(runs);
    const baseLayer = createTerrainLayer(deckApi);
    const pointsLayer = new deckApi.ScatterplotLayer({
      id: 'runs-points',
      data: runs,
      pickable: true,
      radiusUnits: 'pixels',
      getPosition: (d) => d.map_center,
      getRadius: 6,
      getFillColor: [31, 111, 235, 200],
      getLineColor: [255, 255, 255, 200],
      lineWidthUnits: 'pixels',
      getLineWidth: 1,
    });
    const labelsLayer = new deckApi.TextLayer({
      id: 'runs-labels',
      data: runs,
      pickable: true,
      getPosition: (d) => d.map_center,
      getText: (d) => d.label,
      getSize: 14,
      sizeUnits: 'pixels',
      getColor: [31, 111, 235, 235],
      fontFamily: '"Source Sans 3", "Segoe UI", "Helvetica Neue", Arial, sans-serif',
      getPixelOffset: [12, 0],
      getTextAnchor: 'start',
      getAlignmentBaseline: 'center',
      background: true,
      getBackgroundColor: [255, 255, 255, 230],
      backgroundPadding: [6, 4],
    });

    runsMapDeck = new deckApi.Deck({
      parent: runsMapCanvas,
      views: new deckApi.MapView({ repeat: false }),
      initialViewState: viewState,
      controller: {
        dragRotate: false,
        touchRotate: false,
      },
      layers: [baseLayer, pointsLayer, labelsLayer],
      getCursor: ({ isDragging, isHovering }) => {
        if (isDragging) {
          return 'grabbing';
        }
        if (isHovering) {
          return 'pointer';
        }
        return 'grab';
      },
      getTooltip: ({ object }) => {
        if (!object) {
          return null;
        }
        const details = [object.runid];
        if (object.name) {
          details.push(object.name);
        }
        if (object.scenario) {
          details.push(object.scenario);
        }
        return details.filter(Boolean).join(' | ');
      },
      onClick: ({ object }) => {
        if (object && object.url) {
          window.open(object.url, '_blank', 'noopener');
        }
      },
    });
  }

  if (runsSearchInput) {
    runsSearchInput.addEventListener('input', () => applyRunsFilter({ resetPage: true }));
    runsSearchInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        applyRunsFilter({ resetPage: true });
      }
    });
  }
  if (runsSearchGo) {
    runsSearchGo.addEventListener('click', () => applyRunsFilter({ resetPage: true }));
  }
  if (runsSearchClear) {
    runsSearchClear.addEventListener('click', () => {
      if (runsSearchInput) {
        runsSearchInput.value = '';
      }
      applyRunsFilter({ resetPage: true });
    });
  }

  if (runsTabTable) {
    runsTabTable.addEventListener('click', () => setRunsView('table'));
  }
  if (runsTabMap) {
    runsTabMap.addEventListener('click', () => setRunsView('map'));
  }

  if (!runsTable) {
    console.warn('Runs table not found; skipping selection logic.');
    if (deleteButton) {
      deleteButton.disabled = true;
    }
  } else {
    updateDeleteState();
  }

  loadRunsCatalog();
</script>
{% endblock %}

{% block script_extras %}
  {{ super() }}
  <script src="https://unpkg.com/deck.gl@^9.0.0/dist.min.js"></script>
  <script src="{{ url_for('static', filename='js/controllers-gl.js') }}" defer></script>
{% endblock %}
