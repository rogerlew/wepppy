"""Fast parquet summary helpers for NoDb controllers using DuckDB."""

from __future__ import annotations

from os.path import join as _join
from typing import Any, Dict, Union, TYPE_CHECKING

import duckdb

if TYPE_CHECKING:  # pragma: no cover - import only for typing
    import pandas as pd
else:  # pragma: no cover - satisfy type checkers expecting the name
    pd = None  # type: ignore[assignment]

__all__ = [
    'get_soil_sub_summary',
    'get_soil_subs_summary',
    'get_landuse_sub_summary',
    'get_landuse_subs_summary',
    'get_watershed_sub_summary',
    'get_watershed_subs_summary',
    'get_watershed_chn_summary',
    'get_watershed_chns_summary',
]

SummaryRow = Dict[str, Any]


def _get_sub_summary(parquet_fn: str, topaz_id: Union[int, str]) -> SummaryRow:
    """Return a single row from ``parquet_fn`` matching ``topaz_id``.

    The helper inspects the parquet schema to support either ``topaz_id`` or
    ``TopazID`` column naming conventions generated by upstream tools.
    """
    with duckdb.connect() as con:
        # First, get the column names to determine which ID column exists
        columns_query = con.execute(f"SELECT * FROM read_parquet('{parquet_fn}') LIMIT 0").description
        column_names = [desc[0] for desc in columns_query]
        
        # Determine which topaz_id column exists
        if 'topaz_id' in column_names:
            id_column = 'topaz_id'
        elif 'TopazID' in column_names:
            id_column = 'TopazID'
        else:
            raise ValueError(f"Neither 'topaz_id' nor 'TopazID' column found in {parquet_fn}")
        
        result = con.execute(
            f"SELECT * FROM read_parquet('{parquet_fn}') WHERE {id_column} = ?", 
            [topaz_id]
        ).fetchall()
        
        columns = [desc[0] for desc in con.description]
        result = [dict(zip(columns, row)) for row in result]
        return result[0]


def _get_subs_summary(
    parquet_fn: str,
    return_as_df: bool,
) -> Union[Dict[Union[int, str], SummaryRow], 'pd.DataFrame']:
    """Return all rows from ``parquet_fn`` keyed by Topaz ID or as a DataFrame."""
    with duckdb.connect() as con:
        if return_as_df:
            return con.execute(f"SELECT * FROM read_parquet('{parquet_fn}')").fetchdf()
        
        result = con.execute(f"SELECT * FROM read_parquet('{parquet_fn}')").fetchall()
        
        topaz_id_index = None
        columns = []
        
        # CRITICAL: Do NOT break early - must collect ALL column names
        # Breaking after finding topaz_id would result in missing columns like slope_scalar, aspect, etc.
        for i, desc in enumerate(con.description):
            columns.append(desc[0])
            if desc[0] in ('topaz_id', 'TopazID'):
                topaz_id_index = i
                # NOTE: Continue loop to collect remaining columns - do NOT break here

        if topaz_id_index is None:
            raise ValueError(f"Neither 'topaz_id' nor 'TopazID' column found in {parquet_fn}")

        dict_result = {row[topaz_id_index]: dict(zip(columns, row)) for row in result}
        return dict_result
    

def get_soil_sub_summary(wd: str, topaz_id: Union[int, str]) -> SummaryRow:
    """Return the soils summary for a single hillslope ``topaz_id``."""
    parquet_fn = _join(wd, 'soils/soils.parquet')
    return _get_sub_summary(parquet_fn, topaz_id)


def get_soil_subs_summary(
    wd: str,
    return_as_df: bool = False,
) -> Union[Dict[Union[int, str], SummaryRow], 'pd.DataFrame']:
    """Return soils summaries keyed by hillslope id or as a DataFrame."""
    parquet_fn = _join(wd, 'soils/soils.parquet')
    return _get_subs_summary(parquet_fn, return_as_df=return_as_df)


def get_landuse_sub_summary(wd: str, topaz_id: Union[int, str]) -> SummaryRow:
    """Return the landuse summary for a single hillslope ``topaz_id``."""
    parquet_fn = _join(wd, 'landuse/landuse.parquet')
    return _get_sub_summary(parquet_fn, topaz_id)


def get_landuse_subs_summary(
    wd: str,
    return_as_df: bool = False,
) -> Union[Dict[Union[int, str], SummaryRow], 'pd.DataFrame']:
    """Return landuse summaries keyed by hillslope id or as a DataFrame."""
    parquet_fn = _join(wd, 'landuse/landuse.parquet')
    return _get_subs_summary(parquet_fn, return_as_df=return_as_df)
        

def get_watershed_subs_summary(
    wd: str,
    return_as_df: bool = False,
) -> Union[Dict[Union[int, str], SummaryRow], 'pd.DataFrame']:
    """Return watershed hillslope summaries keyed by Topaz ID or DataFrame."""
    parquet_fn = _join(wd, 'watershed/hillslopes.parquet')
    return _get_subs_summary(parquet_fn, return_as_df=return_as_df)

def get_watershed_sub_summary(wd: str, topaz_id: Union[int, str]) -> SummaryRow:
    """Return the watershed hillslope summary for a single ``topaz_id``."""
    parquet_fn = _join(wd, 'watershed/hillslopes.parquet')
    return _get_sub_summary(parquet_fn, topaz_id)


def get_watershed_chn_summary(wd: str, topaz_id: Union[int, str]) -> SummaryRow:
    """Return the watershed channel summary for a single ``topaz_id``."""
    parquet_fn = _join(wd, 'watershed/channels.parquet')
    return _get_sub_summary(parquet_fn, topaz_id)


def get_watershed_chns_summary(
    wd: str,
    return_as_df: bool = False,
) -> Union[Dict[Union[int, str], SummaryRow], 'pd.DataFrame']:
    """Return watershed channel summaries keyed by Topaz ID or DataFrame."""
    parquet_fn = _join(wd, 'watershed/channels.parquet')
    return _get_subs_summary(parquet_fn, return_as_df=return_as_df)
