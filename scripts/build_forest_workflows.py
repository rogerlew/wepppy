#!/usr/bin/env python3

from __future__ import annotations

import argparse
import copy
import sys
from pathlib import Path
from typing import Any, Dict, List

import yaml
import subprocess
import tempfile
import re


REPO_ROOT = Path(__file__).resolve().parents[1]
FOREST_DIR = REPO_ROOT / ".github" / "forest_workflows"
WORKFLOWS_DIR = REPO_ROOT / ".github" / "workflows"
PLAYBACK_FILE = FOREST_DIR / "playback-profiles.yml"
GENERATED_BANNER = "# WARNING: This file is generated by scripts/build_forest_workflows.py. Do NOT edit directly.\n"


class WorkflowLoader(yaml.SafeLoader):
    pass


class WorkflowDumper(yaml.SafeDumper):
    pass


def _strip_bool_resolver(resolvers):
    for ch, entries in list(resolvers.items()):
        if entries is None:
            continue
        resolvers[ch] = [entry for entry in entries if entry[0] != "tag:yaml.org,2002:bool"]


_strip_bool_resolver(WorkflowLoader.yaml_implicit_resolvers)
_strip_bool_resolver(WorkflowDumper.yaml_implicit_resolvers)


def _str_presenter(dumper: WorkflowDumper, data: str):
    style = "|" if "\n" in data else None
    return dumper.represent_scalar("tag:yaml.org,2002:str", data, style=style)


WorkflowDumper.add_representer(str, _str_presenter)


def load_yaml(path: Path) -> Dict[str, Any]:
    with path.open("r", encoding="utf-8") as handle:
        return yaml.load(handle, Loader=WorkflowLoader)


def dump_yaml(data: Dict[str, Any]) -> str:
    return yaml.dump(data, Dumper=WorkflowDumper, sort_keys=False)


def build_workflow(spec: Dict[str, Any], bootstrap: Dict[str, Any]) -> Dict[str, Any]:
    result = copy.deepcopy(spec)
    bootstrap_env = bootstrap.get("env", {})
    setup_steps = bootstrap.get("setup_steps", [])
    cleanup_steps = bootstrap.get("cleanup_steps", [])

    jobs = result.get("jobs", {})
    for job_name, job in jobs.items():
        job_env = copy.deepcopy(bootstrap_env)
        job_env.update(job.get("env", {}))
        job["env"] = job_env

        job_steps = []
        job_steps.extend(copy.deepcopy(setup_steps))
        job_steps.extend(job.get("steps", []))
        job_steps.extend(copy.deepcopy(cleanup_steps))
        job["steps"] = job_steps

    return result


def write_workflow(target: Path, data: Dict[str, Any]) -> None:
    content = GENERATED_BANNER + dump_yaml(data)
    target.write_text(content, encoding="utf-8")


def _pt_to_utc_cron(pt_time: str, offset: int = 7) -> str:
    hour, minute = map(int, pt_time.split(":"))
    utc_hour = (hour + offset) % 24
    return f"{minute:02d} {utc_hour:02d} * * *"


def _playback_specs() -> tuple[List[tuple[str, Dict[str, Any]]], List[Dict[str, Any]]]:
    if not PLAYBACK_FILE.exists():
        return [], []
    entries = load_yaml(PLAYBACK_FILE) or []
    specs: List[tuple[str, Dict[str, Any]]] = []
    for entry in entries:
        workflow_slug = entry["workflow_slug"]
        playback_type = entry["playback_type"]
        title = entry["title"]
        name = f"Profile {playback_type.capitalize()} - {title}"
        cron = _pt_to_utc_cron(entry["schedule_pt"])
        profile_slug = entry["profile_slug"]
        opts = entry.get("playback_options") or []
        artifact_path = entry["artifact_path"]
        artifact_name = entry["artifact_name"]
        description = entry.get("description", title)

        job_name = workflow_slug.replace("-", "_")
        base_command = {
            "run": "run-test-profile",
            "fork": "run-fork-profile",
            "archive": "run-archive-profile",
        }[playback_type]
        opts_str = f" {' '.join(opts)}" if opts else ""
        run_lines = [
            "set -euo pipefail",
            "mkdir -p telemetry",
            f"wctl {base_command} {profile_slug}{opts_str} 2>&1 | tee {artifact_path}",
        ]
        action_verbs = {"run": "Run", "fork": "Fork", "archive": "Archive"}
        run_step_name = f"{action_verbs[playback_type]} {title} profile"

        job = {
            "runs-on": ["self-hosted", "Linux", "X64", "homelab"],
            "timeout-minutes": 120,
            "env": {
                "ADMIN_EMAIL": "${{ secrets.ADMIN_EMAIL }}",
                "ADMIN_PASSWORD": "${{ secrets.ADMIN_PASSWORD }}",
            },
            "steps": [
                {
                    "name": "Health check WEPPcloud service",
                    "run": (
                        "set -euo pipefail\n"
                        "deadline=$((SECONDS + 300))\n"
                        "while true; do\n"
                        "  if curl -fsS https://wc.bearhive.duckdns.org/health >/dev/null; then\n"
                        "    echo \"WEPPcloud service is healthy.\"\n"
                        "    break\n"
                        "  fi\n"
                        "  if [ \"${SECONDS}\" -ge \"${deadline}\" ]; then\n"
                        "    echo \"Timed out waiting for WEPPcloud service to become healthy.\" >&2\n"
                        "    exit 1\n"
                        "  fi\n"
                        "  sleep 5\n"
                        "done\n"
                    ),
                },
                {
                    "name": run_step_name,
                    "run": "\n".join(run_lines),
                },
                {
                    "name": "Upload profile playback log",
                    "if": "always()",
                    "uses": "actions/upload-artifact@v4",
                    "with": {
                        "name": artifact_name,
                        "path": artifact_path,
                        "if-no-files-found": "warn",
                    },
                },
            ],
        }

        spec = {
            "name": name,
            "on": {"schedule": [{"cron": cron}], "workflow_dispatch": None},
            "jobs": {job_name: job},
        }
        specs.append((f"profile-{workflow_slug}.yml", spec))
    return specs, entries


def _format_time_display(pt_time: str) -> str:
    hour, minute = map(int, pt_time.split(":"))
    suffix = "AM"
    if hour >= 12:
        suffix = "PM"
    display_hour = hour % 12 or 12
    return f"{display_hour:02d}:{minute:02d} {suffix}"


def _generate_profile_table(entries: List[Dict[str, Any]]) -> str:
    sorted_entries = sorted(entries, key=lambda e: e["schedule_pt"])
    lines = [
        "| Badge / Run Time (PT) | Description / Profile Name |",
        "| --------------------- | -------------------------- |",
    ]
    for entry in sorted_entries:
        workflow_slug = entry["workflow_slug"]
        playback_type = entry["playback_type"]
        title = entry["title"]
        description = entry.get("description", title)
        profile_slug = entry["profile_slug"]
        display_time = _format_time_display(entry["schedule_pt"])
        base_url = (
            f"https://github.com/rogerlew/wepppy/actions/workflows/profile-{workflow_slug}.yml"
        )
        badge_title = f"Profile {playback_type.capitalize()} - {title}"
        badge_cell = f"[![{badge_title}]({base_url}/badge.svg)]({base_url})<br>{display_time}"
        desc_cell = f"{description}<br>`{profile_slug}`"
        lines.append(f"| {badge_cell} | {desc_cell} |")
    return "\n".join(lines) + "\n"


def _extract_readme_section(text: str) -> str:
    pattern = re.compile(
        r"(### Dev Server Nightly Profile Tests\s*\n)(.*?)(\n## |\Z)",
        re.S,
    )
    match = pattern.search(text)
    if not match:
        raise RuntimeError("Dev Server Nightly Profile Tests section not found in readme.md")
    return match.group(2).strip()


def _update_readme_table(entries: List[Dict[str, Any]], check: bool) -> bool:
    table_text = _generate_profile_table(entries)
    readme_path = REPO_ROOT / "readme.md"
    readme_text = readme_path.read_text(encoding="utf-8")
    current_section = _extract_readme_section(readme_text)
    normalized_current = "\n".join(line.rstrip() for line in current_section.splitlines()).strip()
    normalized_new = "\n".join(line.rstrip() for line in table_text.splitlines()).strip()
    if normalized_current == normalized_new:
        return True
    if check:
        print("Dev Server Nightly Profile Tests table is out of date.", file=sys.stderr)
        return False
    with tempfile.NamedTemporaryFile("w", delete=False, encoding="utf-8") as tmp:
        tmp.write(table_text)
        tmp_path = tmp.name
    try:
        subprocess.run(
            [
                "markdown-edit",
                str(readme_path),
                "replace",
                "Dev Server Nightly Profile Tests",
                "--with",
                tmp_path,
                "--keep-heading",
                "--quiet",
            ],
            check=True,
        )
    finally:
        Path(tmp_path).unlink(missing_ok=True)
    return True


def main() -> int:
    parser = argparse.ArgumentParser(description="Build forest workflows from templates.")
    parser.add_argument(
        "--check",
        action="store_true",
        help="Only check if generated workflows are up-to-date.",
    )
    args = parser.parse_args()

    bootstrap_path = FOREST_DIR / "bootstrap.yml"
    if not bootstrap_path.exists():
        print(f"Bootstrap file missing: {bootstrap_path}", file=sys.stderr)
        return 1
    bootstrap = load_yaml(bootstrap_path)

    spec_files = sorted(
        p
        for p in FOREST_DIR.glob("*.yml")
        if p.name not in {"bootstrap.yml", "playback-profiles.yml"}
    )
    if not spec_files and not PLAYBACK_FILE.exists():
        print("No workflow specs found.", file=sys.stderr)
        return 1

    dirty = False
    spec_entries = [(path.name, load_yaml(path)) for path in spec_files]
    playback_pairs, playback_entries = _playback_specs()
    spec_entries.extend(playback_pairs)

    for file_name, spec in spec_entries:
        generated = build_workflow(spec, bootstrap)
        target_path = WORKFLOWS_DIR / file_name
        rendered = GENERATED_BANNER + dump_yaml(generated)
        if args.check:
            if not target_path.exists() or target_path.read_text(encoding="utf-8") != rendered:
                print(f"{target_path} is out of date.", file=sys.stderr)
                dirty = True
            continue
        write_workflow(target_path, generated)
        print(f"Wrote {target_path}")

    if "playback_entries" not in locals():
        playback_entries = []
    if playback_entries:
        if not _update_readme_table(playback_entries, args.check):
            dirty = True

    if args.check and dirty:
        return 1
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
