#!/usr/bin/env python3

from __future__ import annotations

import argparse
import copy
import sys
from pathlib import Path
from typing import Any, Dict

import yaml


REPO_ROOT = Path(__file__).resolve().parents[1]
FOREST_DIR = REPO_ROOT / ".github" / "forest_workflows"
WORKFLOWS_DIR = REPO_ROOT / ".github" / "workflows"
GENERATED_BANNER = "# WARNING: This file is generated by scripts/build_forest_workflows.py. Do NOT edit directly.\n"


def load_yaml(path: Path) -> Dict[str, Any]:
    with path.open("r", encoding="utf-8") as handle:
        return yaml.safe_load(handle)


class WorkflowDumper(yaml.SafeDumper):
    pass


for ch, resolvers in list(WorkflowDumper.yaml_implicit_resolvers.items()):
    if resolvers is None:
        continue
    filtered = [item for item in resolvers if item[0] != "tag:yaml.org,2002:bool"]
    WorkflowDumper.yaml_implicit_resolvers[ch] = filtered


def _str_presenter(dumper: WorkflowDumper, data: str):
    style = "|" if "\n" in data else None
    return dumper.represent_scalar("tag:yaml.org,2002:str", data, style=style)


WorkflowDumper.add_representer(str, _str_presenter)


def dump_yaml(data: Dict[str, Any]) -> str:
    return yaml.dump(data, Dumper=WorkflowDumper, sort_keys=False)


def build_workflow(spec_path: Path, bootstrap: Dict[str, Any]) -> Dict[str, Any]:
    spec = load_yaml(spec_path)
    result = copy.deepcopy(spec)
    bootstrap_env = bootstrap.get("env", {})
    setup_steps = bootstrap.get("setup_steps", [])
    cleanup_steps = bootstrap.get("cleanup_steps", [])

    jobs = result.get("jobs", {})
    for job_name, job in jobs.items():
        job_env = copy.deepcopy(bootstrap_env)
        job_env.update(job.get("env", {}))
        job["env"] = job_env

        job_steps = []
        job_steps.extend(copy.deepcopy(setup_steps))
        job_steps.extend(job.get("steps", []))
        job_steps.extend(copy.deepcopy(cleanup_steps))
        job["steps"] = job_steps

    return result


def write_workflow(target: Path, data: Dict[str, Any]) -> None:
    content = GENERATED_BANNER + dump_yaml(data)
    target.write_text(content, encoding="utf-8")


def main() -> int:
    parser = argparse.ArgumentParser(description="Build forest workflows from templates.")
    parser.add_argument(
        "--check",
        action="store_true",
        help="Only check if generated workflows are up-to-date.",
    )
    args = parser.parse_args()

    bootstrap_path = FOREST_DIR / "bootstrap.yml"
    if not bootstrap_path.exists():
        print(f"Bootstrap file missing: {bootstrap_path}", file=sys.stderr)
        return 1
    bootstrap = load_yaml(bootstrap_path)

    spec_files = sorted(p for p in FOREST_DIR.glob("*.yml") if p.name != "bootstrap.yml")
    if not spec_files:
        print("No workflow specs found.", file=sys.stderr)
        return 1

    dirty = False
    for spec_path in spec_files:
        generated = build_workflow(spec_path, bootstrap)
        target_path = WORKFLOWS_DIR / spec_path.name
        rendered = GENERATED_BANNER + dump_yaml(generated)
        if args.check:
            if not target_path.exists() or target_path.read_text(encoding="utf-8") != rendered:
                print(f"{target_path} is out of date.", file=sys.stderr)
                dirty = True
            continue
        write_workflow(target_path, generated)
        print(f"Wrote {target_path}")

    if args.check and dirty:
        return 1
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
